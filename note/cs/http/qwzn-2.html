<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>http权威指南读书笔记 | Geoffrey&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.png">
    <meta name="description" content="若开始，请至终。">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.359545e8.js" as="script"><link rel="preload" href="/assets/js/2.b5c36d7c.js" as="script"><link rel="preload" href="/assets/js/32.2aee8a1d.js" as="script"><link rel="prefetch" href="/assets/js/10.00e69cef.js"><link rel="prefetch" href="/assets/js/11.57586c14.js"><link rel="prefetch" href="/assets/js/12.7a34a4de.js"><link rel="prefetch" href="/assets/js/13.adeebbe5.js"><link rel="prefetch" href="/assets/js/14.192a60ca.js"><link rel="prefetch" href="/assets/js/15.e17762bb.js"><link rel="prefetch" href="/assets/js/16.481beb27.js"><link rel="prefetch" href="/assets/js/17.7c1f766e.js"><link rel="prefetch" href="/assets/js/18.64f0b6b3.js"><link rel="prefetch" href="/assets/js/19.0d476176.js"><link rel="prefetch" href="/assets/js/20.8367d564.js"><link rel="prefetch" href="/assets/js/21.86eabb08.js"><link rel="prefetch" href="/assets/js/22.4d95cc8b.js"><link rel="prefetch" href="/assets/js/23.37b2e9bc.js"><link rel="prefetch" href="/assets/js/24.b803d449.js"><link rel="prefetch" href="/assets/js/25.dacb70e7.js"><link rel="prefetch" href="/assets/js/26.d4ece38f.js"><link rel="prefetch" href="/assets/js/27.0dcb5dbe.js"><link rel="prefetch" href="/assets/js/28.d0ba2fbd.js"><link rel="prefetch" href="/assets/js/29.10c0d23e.js"><link rel="prefetch" href="/assets/js/3.4243e3dc.js"><link rel="prefetch" href="/assets/js/30.050cda80.js"><link rel="prefetch" href="/assets/js/31.69c2c5b5.js"><link rel="prefetch" href="/assets/js/33.8b539eaf.js"><link rel="prefetch" href="/assets/js/34.a0b03ef8.js"><link rel="prefetch" href="/assets/js/35.721ada8b.js"><link rel="prefetch" href="/assets/js/36.39e28637.js"><link rel="prefetch" href="/assets/js/37.07766141.js"><link rel="prefetch" href="/assets/js/38.d5beb18d.js"><link rel="prefetch" href="/assets/js/39.d049273c.js"><link rel="prefetch" href="/assets/js/4.6ae73e56.js"><link rel="prefetch" href="/assets/js/40.353cf2b6.js"><link rel="prefetch" href="/assets/js/41.831bb4d3.js"><link rel="prefetch" href="/assets/js/42.26037e45.js"><link rel="prefetch" href="/assets/js/43.60990ea1.js"><link rel="prefetch" href="/assets/js/44.13959e9e.js"><link rel="prefetch" href="/assets/js/45.5834156e.js"><link rel="prefetch" href="/assets/js/46.4363792b.js"><link rel="prefetch" href="/assets/js/47.cd0f3325.js"><link rel="prefetch" href="/assets/js/48.cbfc5ce6.js"><link rel="prefetch" href="/assets/js/49.74075f59.js"><link rel="prefetch" href="/assets/js/5.b0e4397f.js"><link rel="prefetch" href="/assets/js/50.7dc25b35.js"><link rel="prefetch" href="/assets/js/51.f10eb728.js"><link rel="prefetch" href="/assets/js/52.63cbadfa.js"><link rel="prefetch" href="/assets/js/53.06c6a6a2.js"><link rel="prefetch" href="/assets/js/54.d928c0c0.js"><link rel="prefetch" href="/assets/js/55.774396e5.js"><link rel="prefetch" href="/assets/js/56.aeef48d0.js"><link rel="prefetch" href="/assets/js/57.fce5c3c1.js"><link rel="prefetch" href="/assets/js/58.7b981549.js"><link rel="prefetch" href="/assets/js/59.fd9d9a96.js"><link rel="prefetch" href="/assets/js/6.5ac1eaeb.js"><link rel="prefetch" href="/assets/js/60.e6100b0a.js"><link rel="prefetch" href="/assets/js/61.c5ccbe88.js"><link rel="prefetch" href="/assets/js/62.b93fec04.js"><link rel="prefetch" href="/assets/js/63.4f139bc7.js"><link rel="prefetch" href="/assets/js/64.8bd0f7d1.js"><link rel="prefetch" href="/assets/js/65.d04f4f40.js"><link rel="prefetch" href="/assets/js/66.a5720b4a.js"><link rel="prefetch" href="/assets/js/67.cc73b530.js"><link rel="prefetch" href="/assets/js/68.60903f94.js"><link rel="prefetch" href="/assets/js/69.95f3ba7b.js"><link rel="prefetch" href="/assets/js/7.3aaf5305.js"><link rel="prefetch" href="/assets/js/70.d2b0133c.js"><link rel="prefetch" href="/assets/js/71.5c1c9879.js"><link rel="prefetch" href="/assets/js/72.db407689.js"><link rel="prefetch" href="/assets/js/73.989047da.js"><link rel="prefetch" href="/assets/js/74.f889cee0.js"><link rel="prefetch" href="/assets/js/75.1faecbbe.js"><link rel="prefetch" href="/assets/js/76.d8e9156c.js"><link rel="prefetch" href="/assets/js/77.3750d42b.js"><link rel="prefetch" href="/assets/js/78.2512d41f.js"><link rel="prefetch" href="/assets/js/79.75448855.js"><link rel="prefetch" href="/assets/js/8.f62010f1.js"><link rel="prefetch" href="/assets/js/80.c219fe62.js"><link rel="prefetch" href="/assets/js/9.e11ebc74.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Geoffrey's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  学习笔记
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法学习
</a></div><div class="nav-item"><a href="/fe-interview/" class="nav-link">
  FE-Interview
</a></div> <a href="https://github.com/geoffrey-ne/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  学习笔记
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法学习
</a></div><div class="nav-item"><a href="/fe-interview/" class="nav-link">
  FE-Interview
</a></div> <a href="https://github.com/geoffrey-ne/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/note/javascript/professional-javascript-3/04-var-scope-memory" class="sidebar-heading clickable"><span>JavaScript</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/note/typescript/01-base" class="sidebar-heading clickable"><span>Typescript</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/note/cs/http/qwzn-1" class="sidebar-heading clickable open"><span>CS</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/note/cs/http/qwzn-1" class="sidebar-heading clickable open"><span>HTTP</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/cs/http/qwzn-1.html" class="sidebar-link">http权威指南：第一部分 Web的基础</a></li><li><a href="/note/cs/http/qwzn-2.html" aria-current="page" class="active sidebar-link">http权威指南：第二部分 HTTP结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-2.html#_5-web服务器" class="sidebar-link">5. Web服务器</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-2.html#_6-代理" class="sidebar-link">6. 代理</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-2.html#_7-缓存" class="sidebar-link">7. 缓存</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-2.html#_8-集成点-网关、隧道及中继" class="sidebar-link">8. 集成点：网关、隧道及中继</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-2.html#_9-web机器人" class="sidebar-link">9. Web机器人</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-2.html#_10-http-ng" class="sidebar-link">10. HTTP-NG</a></li></ul></li></ul></section></li><li><a href="/note/cs/web-cache.html" class="sidebar-link">web 缓存</a></li><li><a href="/note/cs/linux.html" class="sidebar-link">linux常用指令</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http权威指南"><a href="#http权威指南" class="header-anchor">#</a> http权威指南</h1> <h1 id="第二部分-http结构"><a href="#第二部分-http结构" class="header-anchor">#</a> 第二部分 HTTP结构</h1> <h2 id="_5-web服务器"><a href="#_5-web服务器" class="header-anchor">#</a> 5. Web服务器</h2> <ul><li>对不同类型软硬件的Web服务器进行调查；—— 标准计算机、服务器设备、嵌入式服务器</li> <li>如何使用Perl编写简单的诊断性Web服务器；</li> <li>一步步解释Web服务器是如何处理HTTP事务的。接受客户端请求连接、接收请求报文、处理请求、对资源的映射及访问、构建响应、发送响应、记录日志。</li></ul> <h3 id="_5-1-各种形状和尺寸的web服务器"><a href="#_5-1-各种形状和尺寸的web服务器" class="header-anchor">#</a> 5.1 各种形状和尺寸的Web服务器</h3> <p>所有的Web服务器都能够接收请求资源的HTTP请求，将内容回送给客户端。</p> <p>Web服务器实现了HTTP协议、管理Web资源，与操作系统共同负责管理TCP连接。底层操作系统负责硬件细节，并提供了TCP/IP网络支持、负责装载Web资源的文件系统以及控制当前计算活动的进程管理功能。</p> <p>Web服务器有各种不同形式：</p> <ul><li>标准计算机系统上安装并运行通用的软件Web服务器。比如：Apache，IIS等；</li> <li>服务器设备，预先打包好的软硬件解决方案。cobalt、toshiba等；</li> <li>嵌入式Web服务器，简单便携。IPic、SitePlayer等。</li></ul> <h3 id="_5-2-最小的perl-web服务器"><a href="#_5-2-最小的perl-web服务器" class="header-anchor">#</a> 5.2 最小的Perl Web服务器</h3> <p>就是写了些简短的服务器处理请求代码。</p> <h3 id="_5-3-实际的web服务器会做些什么"><a href="#_5-3-实际的web服务器会做些什么" class="header-anchor">#</a> 5.3 实际的Web服务器会做些什么</h3> <ul><li>建立连接——接受一个客户端连接，如果不希望建立，就将其关闭；</li> <li>接收请求——从网络中读取一条HTTP请求报文；</li> <li>处理请求——对请求进行解释，并采取行动；</li> <li>访问资源——访问报文中指定资源；</li> <li>构建响应——创建带有正确首部的HTTP响应报文；</li> <li>发送响应——将响应回送给客户端；</li> <li>记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中。</li></ul> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190613151607293.png" alt="image-20190613151607293"></p> <h3 id="_5-4-第一步-接受客户端连接"><a href="#_5-4-第一步-接受客户端连接" class="header-anchor">#</a> 5.4 第一步——接受客户端连接</h3> <p>如果客户端已经打开一条到服务器的持久连接，可以使用那条连接来发送它的请求。否则需要建立一条新的连接。</p> <ul><li>处理新连接：客户端请求一条到Web服务器的TCP连接时，Web服务器会建立连接，并从TCP连接中将IP地址解析出来，将新连接添加到其现存Web服务器连接列表中，做好监视连接上数据传输的准备。Web服务器可以随意拒绝或立即关闭任意一条连接。</li> <li>客户端主机名识别：可以用”反向DNS”将客户端IP地址转换成客户端主机名。但这可能会花费很长时间，降低Web事务处理的速度；</li> <li>通过ident确定客户端用户：有些Web服务器还支持IETF的ident协议，服务器可以通过ident协议找到发起HTTP连接的用户名。但出于多种原因，在公共因特网上并不能很好地工作。</li></ul> <h3 id="_5-5-第二步-接收请求报文"><a href="#_5-5-第二步-接收请求报文" class="header-anchor">#</a> 5.5 第二步——接收请求报文</h3> <p>连接上有数据到达时，Web服务器会从网络连接中读取数据，并将请求报文中的内容解析出来。</p> <p>解析请求报文时。Web服务器会：</p> <ul><li>解析首行，查找请求方法、指定的资源标识符以及版本号，各项间由一个空格分隔，以回车换行作为行结束；</li> <li>读取以CRLF结尾的首部；读取首部空行；</li> <li>（如果有的话）读取请求主体，长度由Content-Length首部决定。</li></ul> <p>服务器需要从网络读取数据，网络连接随时可能会出现延迟，所以服务器会将报文数据临时存储在内存中，知道收到足以进行解析的数据并理解意义为止。</p> <p>因为请求可能会在任意时刻到达，所以Web服务器会不停地观察有无新的Web请求，不同结构的服务器会以不同方式为请求服务。</p> <ul><li>单线程服务器：一次只处理一个请求，直到完成为止。这种结构易于实现，但时延高，只适用于低负荷的服务器；</li> <li>多进程及多线程服务器：可以按需创建或者预先创建一些。一般会限制线程/进程的最大数量；</li> <li>复用I/0服务器：在复用结构中，要同时监视所有连接上的活动。当连接的状态发生变化时，就对那条连接进行少量的处理；处理结束之后，将连接返回到开放连接列表中，等待下一次状态变化，在空闲连接上等待的时候并不会绑定线程和进程；</li> <li>复用的多线程服务器：多线程中的每一个都在观察打开的连接，并对每条连接执行少量的任务。</li></ul> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190614170036379.png" alt="image-20190614170036379"></p> <h3 id="_5-6-第三步-处理请求"><a href="#_5-6-第三步-处理请求" class="header-anchor">#</a> 5.6 第三步——处理请求</h3> <p>没细讲</p> <h3 id="_5-7-第四步-对资源的映射及访问"><a href="#_5-7-第四步-对资源的映射及访问" class="header-anchor">#</a> 5.7 第四步——对资源的映射及访问</h3> <h4 id="_5-7-1-docroot"><a href="#_5-7-1-docroot" class="header-anchor">#</a> 5.7.1 docroot</h4> <p>Web服务器支持各种不同类型的资源映射，其中最简单的形式就是用URI作为名字来访问服务器文件系统中的文件。服务器通常有一个特殊的文件夹专门用于存放Web内容，这个文件夹被称为document root，docroot。比如：</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190617101533897.png" alt="image-20190617101533897"></p> <p>服务器根目录为<code>/usr/local/httpd/files</code>，请求为<code>/specials/saw-blade.gif</code>，服务器会返回文件：<code>/usr/local/httpd/files/specials/saw-blade.gif</code>。</p> <p>服务器要注意，不能让相对URL退到docroot之外，将文件系统的其余部分暴露出来。比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>http://www.joes-hardware.com/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>虚拟托管的docroot：有时候我们需要用一台服务器托管两个站点，比如：<code>www.test1.com</code>和<code>www.test2.com</code>，但是要求不同站点在服务器上都有自己独有的文档根目录，虚拟托管的docroot可以根据URI或者Host首部的IP地址或主机名来识别正确的文档目录；</li> <li>用户的主目录docroot：在Web服务器上为用户提供私有的Web站点，通常会把那些以斜杠和波浪线号开始，后面跟着用户名的URL映射为此用户的私有文档根目录。</li></ul> <h4 id="_5-7-2-目录列表"><a href="#_5-7-2-目录列表" class="header-anchor">#</a> 5.7.2 目录列表</h4> <p>服务器可以接收对目录URL的请求，其路径可以解析为一个目录，而不是文件。我们可以对服务器进行配置，使其在客户端请求目录URL时采取不同动作。</p> <ul><li>返回一个错误；</li> <li>不返回目录，返回一个特殊的默认“索引文件”；</li> <li>扫描目录，返回一个包含目录内容的HTML页面。</li></ul> <h4 id="_5-7-3-动态内容资源的映射"><a href="#_5-7-3-动态内容资源的映射" class="header-anchor">#</a> 5.7.3 动态内容资源的映射</h4> <p>服务器还可以将URI映射为动态资源，映射到按需动态生成内容的程序上去，亦即应用程序服务器。会将连接映射到复杂的后端应用程序上去。（个人理解就是接口）</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190617103004050.png" alt="image-20190617103004050"></p> <h4 id="_5-7-4-服务器端包含项"><a href="#_5-7-4-服务器端包含项" class="header-anchor">#</a> 5.7.4 服务器端包含项</h4> <h4 id="_5-7-5-访问控制"><a href="#_5-7-5-访问控制" class="header-anchor">#</a> 5.7.5 访问控制</h4> <p>访问受控资源时，服务器可以根据客户端的IP地址进行访问控制，也可以要求输入密码来访问资源。HTTP认证详见12章</p> <h3 id="_5-8-第五步-构建响应"><a href="#_5-8-第五步-构建响应" class="header-anchor">#</a> 5.8 第五步——构建响应</h3> <h4 id="_5-8-1-响应实体"><a href="#_5-8-1-响应实体" class="header-anchor">#</a> 5.8.1 响应实体</h4> <p>响应报文通常包括：</p> <ul><li>描述主体MIME类型的Content-Type首部；</li> <li>描述主体长度的Content-Length首部；</li> <li>实际报文的主体内容。</li></ul> <h4 id="_5-8-2-mime类型"><a href="#_5-8-2-mime类型" class="header-anchor">#</a> 5.8.2 MIME类型</h4> <p>服务器需要负责确定响应主体的MIME类型，有很多配置服务器的方法可以将MIME类型与资源关联起来。</p> <ul><li>MIME类型(mime.types)：用文件的扩展名来说明MIME类型；</li></ul> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190617104038126.png" alt="image-20190617104038126"></p> <ul><li>魔法分类(Magic typing)：服务器扫描资源内容，并将其与一个已知模式表（魔法文件）进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但是很方便，尤其是文件没有标准扩展名的时候；</li> <li>显示分类：不考虑文件的扩展名和内容，强制特定文件或目录拥有某个MIME类型。</li> <li>类型协商：有些服务器经过配置，可以以多种文档格式来存储资源，可以通过与用户协商来决定哪种格式最好。详见17章。</li></ul> <h4 id="_5-8-3-重定向"><a href="#_5-8-3-重定向" class="header-anchor">#</a> 5.8.3 重定向</h4> <p>服务器有时会返回重定向响应而不是成功报文。重定向响应由返回码3XX说明。Location响应首部包含了内容的新地址或优选地址的URI。重定向可用于下列情况：</p> <ul><li>永久删除的资源：资源可能已经移动到新位置，或者被重命名，有了新的URL；状态码301；</li> <li>临时删除的资源：移动或者重命名是临时的。状态码303 See Other及307 Temporary Redirect；</li> <li>URL增强：服务器通常用重定向来重写URL，往往用于嵌入上下文；</li> <li>负载均衡：一个超载的服务器收到一条请求，服务器可以将客户端重定向到一个负载不太重的服务器上去；</li> <li>服务器关联：某台服务器上可能会有某些用户的本地信息，服务器可以将客户端重定向到包含了那个客户端信息的服务器上去；</li> <li>规范目录名称：请求URI是一个不带尾部斜线的目录名时，大多数服务器会将客户端重定向到一个加了斜线的URI上。</li></ul> <h3 id="_5-9-第六步-发送响应"><a href="#_5-9-第六步-发送响应" class="header-anchor">#</a> 5.9 第六步——发送响应</h3> <p>服务器要记录连接的状态。对于非持久连接应该在发送整条报文之后关闭自己这一端的连接；对于持久连接来说，连接可能仍要保持打开状态，这种情况下，服务器要正确计算Content-Length首部，不然客户端就无法知道响应什么时候结束。</p> <h3 id="_5-10-第七步-记录日志"><a href="#_5-10-第七步-记录日志" class="header-anchor">#</a> 5.10 第七步——记录日志</h3> <p>当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务。详见21章。</p> <h2 id="_6-代理"><a href="#_6-代理" class="header-anchor">#</a> 6. 代理</h2> <p>代理是位于服务器与客户端之间，扮演“中间人”的角色。</p> <ul><li>解释什么是代理，其与网关的区别，如何部署代理；—— 客户端与服务器之间的实体</li> <li>代理所能提供的帮助；—— 缓存、防火墙、反向代理、内容路由器、转码器、匿名者</li> <li>现实网络中是怎样部署代理以及如何将网络流量导向代理服务器；—— 区分客户端代理、ISP代理、反向代理、拦截代理等</li> <li>如何配置浏览器来使用代理；——手动、PAC、WPAD协议</li> <li>展示HTTP的代理请求，说明它与服务器请求的区别，以及代理是如何微妙地改变浏览器行为的；—— 部分路径与全部路径</li> <li>如何通过Via首部和TRACE方法记录报文传输路径上的代理服务器链；—— 将中间代理信息记录到VIA字段</li> <li>描述基于代理的HTTP访问控制方法；——详见12章</li> <li>解释代理如何与客户端和服务器进行交互，每个客户端和服务器支持的特性和使用版本都有可能有所不同。—— 代理如果理解不了首部，应该直接转发；使用OPTIONS可以查看对可选特性的支持</li></ul> <h3 id="_6-1-web的中间实体"><a href="#_6-1-web的中间实体" class="header-anchor">#</a> 6.1 Web的中间实体</h3> <p>Web上的代理服务器是代表客户端完成事务处理的中间人，它既是客户端，也是服务器。</p> <h4 id="_6-1-1-私有和共享代理"><a href="#_6-1-1-私有和共享代理" class="header-anchor">#</a> 6.1.1 私有和共享代理</h4> <p>单个客户端专用的代理称为私有代理（比如ss）；众多客户端共享的代理称为公共代理（比如高速缓存代理服务器）。</p> <h4 id="_6-1-2-代理与网关的对比"><a href="#_6-1-2-代理与网关的对比" class="header-anchor">#</a> 6.1.2 代理与网关的对比</h4> <p>严格来说，代理连接的是两个或多个使用相同协议的应用程序，而网关扮演的是“协议转换器”的角色，连接的是两个或多个使用不同协议的端点。</p> <p>实际上，代理和网关的区别很模糊。代理经常也需要做一些协议转换工作。商业化代理也会实现网关的功能来支持ssl安全协议、SOCKS防火墙、FTP访问。</p> <h3 id="_6-2-为什么使用代理"><a href="#_6-2-为什么使用代理" class="header-anchor">#</a> 6.2 为什么使用代理</h3> <p>代理服务器可以提供很多有用的功能，比如改善安全性，提高性能，节省费用。</p> <ul><li><p>儿童过滤器：为教育站点提供无阻碍访问的同时，利用过滤器代理来阻止学生访问成人内容；</p></li> <li><p>文档访问控制：比如集中控制某些客户端对不同文件的不同访问权限；</p></li> <li><p>安全防火墙：使用代理服务器限制哪些应用层协议的数据可以流入或流出一个组织。</p></li> <li><p>web缓存：代理缓存维护常用文档的本地副本；</p></li> <li><p>反向代理：代理假扮服务器，这些被称为替代物或反向代理的代理接收发给服务器的请求，按需定位所请求的内容，返回给客户端；</p></li> <li><p>内容路由器：根据流量状况以及内容类型将请求导向特定的服务器（有点像nginx）；</p></li> <li><p>转码器：将内容发送给客户端之前，可以修改内容的主体格式，比如图片压缩，语言转换等；</p></li> <li><p>匿名者：代理主动从HTTP报文中删除身份特性，比如IP地址、From首部、Referer首部、cookie等。</p></li></ul> <h3 id="_6-3-代理会去往何处"><a href="#_6-3-代理会去往何处" class="header-anchor">#</a> 6.3 代理会去往何处</h3> <ul><li>怎样将代理部署到网络中去；</li> <li>怎样将代理以层级的方式连接在一起；</li> <li>怎样先将网络流量直接导入代理服务器中。</li></ul> <h4 id="_6-3-1-代理服务器的部署"><a href="#_6-3-1-代理服务器的部署" class="header-anchor">#</a> 6.3.1 代理服务器的部署</h4> <p>可以根据用途，将代理放在任意位置。</p> <ul><li>出口代理：将代理固定在网络的出口点，可以控制内网与外网之间的流量，比如防火墙保护，降低带宽费用，提高因特网流量的性能，过滤不恰当内容等；</li> <li>访问（入口）代理：放在ISP访问点上，用以处理来自客户的聚合请求。IPS使用缓存代理来存储常用文档的副本，以提高用户的下载速度，降低带宽耗费；</li> <li>反向代理：被部署在服务端的网络边缘，在访问服务器之前，先处理所有传送给服务器的请求，只在必要时，向服务器请求资源；</li> <li>网络交换代理：放在网络之间对等交换点上，通过缓存减轻网络节点的拥塞，并对流量进行监视。</li></ul> <h4 id="_6-3-2-代理的层次结构"><a href="#_6-3-2-代理的层次结构" class="header-anchor">#</a> 6.3.2 代理的层次结构</h4> <p>可以通过代理的层次结构将代理级联起来。报文从一个代理传给另一个代理，直到最后抵达原始服务器。Proxy层次结构中的代理服务器被赋予了父子关系。下一个入口代理（靠近服务器）被称为父代理，反之称为子代理。</p> <p>除了固定（静态）的层次结构，代理也可以根据不同情况将报文转发给一个不断变化的代理服务器和原始服务器集。比如均衡负载、地理位置附近的路由、协议/类型路由、基于订购的路由。</p> <h4 id="_6-3-3-代理是如何获取流量的"><a href="#_6-3-3-代理是如何获取流量的" class="header-anchor">#</a> 6.3.3 代理是如何获取流量的</h4> <ul><li>修改客户端：很多客户端，包括浏览器，都支持手工和自动的代理配置，客户端将HTTP请求有意地直接发送给代理，而不是原始服务器；</li> <li>修改网络：也称为拦截代理，在网络基础设施中增加代理节点。在客户端不知情的情况下，进行拦截；</li> <li>修改DNS的命名空间：也就是反向代理，将域名直接映射到反向代理，或者手工编辑DNS名称列表等；</li> <li>修改服务器：服务器将请求直接重定向到代理去。</li></ul> <h3 id="_6-4-客户端代理设置"><a href="#_6-4-客户端代理设置" class="header-anchor">#</a> 6.4 客户端代理设置</h3> <ul><li>手动配置：显示设置要使用的代理。简单但死板，只能为所有内容指定唯一的一个代理服务器；</li> <li>PAC文件：一个小型的javascript程序，提供了针对不同url，计算恰当代理服务器的能力。要使用PAC文件，需要手工配置一个URI；</li> <li>WPAD协议：该算法会使用发现机制逐级上升策略自动地为浏览器查找合适的PAC文件。详见20章。</li></ul> <h3 id="_6-5-与代理请求有关的一些棘手问题"><a href="#_6-5-与代理请求有关的一些棘手问题" class="header-anchor">#</a> 6.5 与代理请求有关的一些棘手问题</h3> <ul><li>代理请求的URI与服务器请求的URI有何不同；</li> <li>拦截和反向代理是如何将服务器主机信息隐藏起来的；</li> <li>修改URI的规则；</li> <li>代理是怎样影响浏览器的只能URI自动完成机制，或主机名扩展特性的。</li></ul> <h4 id="_6-5-1-代理uri与服务器uri的不同"><a href="#_6-5-1-代理uri与服务器uri的不同" class="header-anchor">#</a> 6.5.1 代理URI与服务器URI的不同</h4> <p>客户端向服务器直接发送请求时，请求行中只包含部分URI，没有方案、主机或端口。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>GET /index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>但当明确向代理发送请求时，请求行中则包含完整的URI。例如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>GET http://www.baidu.com/index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>代理需要知道目标服务器的名称才能建立与服务器之间的连接。</p> <h4 id="_6-5-2-与虚拟主机一样的问题"><a href="#_6-5-2-与虚拟主机一样的问题" class="header-anchor">#</a> 6.5.2 与虚拟主机一样的问题</h4> <p>虚拟主机服务器会在很多web站点间共享同一物理web服务器。所以虚拟主机服务器要求使用Host首部来承载主机和端口信息。</p> <h4 id="_6-5-3-拦截代理会收到部分uri"><a href="#_6-5-3-拦截代理会收到部分uri" class="header-anchor">#</a> 6.5.3 拦截代理会收到部分URI</h4> <p>对于反向代理和拦截代理而言，客户端无法区分是服务器还是代理，所以客户端会发送部分URI。</p> <h4 id="_6-5-4-代理既可以处理代理请求-也可以处理服务器请求"><a href="#_6-5-4-代理既可以处理代理请求-也可以处理服务器请求" class="header-anchor">#</a> 6.5.4 代理既可以处理代理请求，也可以处理服务器请求</h4> <p>通用代理应该既支持完整URI，也支持部分URI。使用完整和部分URI的规则如下所示。</p> <ul><li>如果提供的是完整URI，代理就应该使用完整URI；</li> <li>如果提供的是部分URI，而且有Host首部，就应该用Host来确定原始服务器的名字和端口号；</li> <li>如果是部分URI，而且没有Host首部：
<ul><li>如果代理是反向代理，可以用真实服务器的地址和端口号来配置代理；</li> <li>如果是拦截代理，而且拦截者也可以提供原始IP和端口，代理就可以直接使用；</li> <li>如果都失败了，就必须返回一条错误报文。</li></ul></li></ul> <h4 id="_6-5-5-转发过程中对uri的修改"><a href="#_6-5-5-转发过程中对uri的修改" class="header-anchor">#</a> 6.5.5 转发过程中对URI的修改</h4> <p>代理服务器在转发报文的时候，应该尽量宽容一些，而不是成为强制实现严格协议一致性的“协议警察”，这样可能破坏之前正常工作的服务。</p> <h4 id="_6-5-6-uri的客户端自动扩展和主机名解析"><a href="#_6-5-6-uri的客户端自动扩展和主机名解析" class="header-anchor">#</a> 6.5.6 URI的客户端自动扩展和主机名解析</h4> <p>在没有代理的时候，浏览器可能会尝试自动补全“www.”和后缀“.com”以防用户只输入常见web站点的中间部分。但当有代理的时候，发送给代理的请求不会自动补全，只会添加默认方案和路径。</p> <h3 id="_6-6-追踪报文"><a href="#_6-6-追踪报文" class="header-anchor">#</a> 6.6 追踪报文</h3> <p>via首部用于列出报文途经的每个中间节点信息，报文每经过一个节点，都必须将这个节点添加到Via列表的末尾。</p> <p>![image-20190624151346762](/Users/wangyunfei/Library/Application Support/typora-user-images/image-20190624151346762.png)</p> <p>而Server响应首部字段，对原始服务器进行了描述，所以代理不应该修改Server首部。</p> <h6 id="trace方法"><a href="#trace方法" class="header-anchor">#</a> TRACE方法</h6> <p>通过HTTP/1.1的TRACE方法，用户可以跟踪经代理链传输的请求报文。</p> <p>Max-Forwards首部可以限制TRACE和OPTIONS请求所经过的代理调数。</p> <h3 id="_6-7-代理认证"><a href="#_6-7-代理认证" class="header-anchor">#</a> 6.7 代理认证</h3> <p>详见12章</p> <h3 id="_6-8-代理的互操作性"><a href="#_6-8-代理的互操作性" class="header-anchor">#</a> 6.8 代理的互操作性</h3> <p>代理服务器必须将不认识的首部字段进行转发，而且必须维持同名首部的相对顺序。</p> <p>使用OPTIONS，客户端或代理可以发现服务器或者其上某个特定资源所支持的功能。如果OPTIONS请求的URI是个星号，请求的就是整个服务器所支持的功能。比如：OPTIONS * HTTP/1.1</p> <p>![image-20190624152425864](/Users/wangyunfei/Library/Application Support/typora-user-images/image-20190624152425864.png)</p> <p>在响应报文中，唯一指定首部字段Allow，来描述支持的各种方法。</p> <h2 id="_7-缓存"><a href="#_7-缓存" class="header-anchor">#</a> 7. 缓存</h2> <p>web缓存是可以自动保存常见文档副本的HTTP设备。当请求到达时，如果本地有“已缓存的”副本，就可以从本地提取文档，而不是原始服务器。</p> <ul><li>缓存怎样提高性能降低费用；</li> <li>如何衡量有效性以及将缓存置于何处可以发挥它的最大作用；</li> <li>HTTP如何保持已缓存副本的新鲜度；</li> <li>缓存如何与其他缓存和服务器通信。</li></ul> <h4 id="_7-1-冗余的数据传输"><a href="#_7-1-冗余的数据传输" class="header-anchor">#</a> 7.1 冗余的数据传输</h4> <p>同一文档多次请求，重复冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重服务器的负载。有缓存之后，就可以保留一个服务器响应的副本，后继请求可以使用缓存，减少那些流入/流出原始服务器的，被浪费掉的重复流量。</p> <h3 id="_7-2-带宽瓶颈"><a href="#_7-2-带宽瓶颈" class="header-anchor">#</a> 7.2 带宽瓶颈</h3> <p>很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到一份副本，那么缓存就可以提高性能，尤其是大文件传输时。</p> <h3 id="_7-3-瞬间拥塞"><a href="#_7-3-瞬间拥塞" class="header-anchor">#</a> 7.3 瞬间拥塞</h3> <p>突然事件造成很多人几乎同时去访问一个web文档，就会出现瞬间拥塞，由此造成的过多流量峰值可能会使网络和服务器产生灾难性的崩溃。</p> <h3 id="_7-4-距离时延"><a href="#_7-4-距离时延" class="header-anchor">#</a> 7.4 距离时延</h3> <p>即使带宽不是问题，距离也可能成为问题，每台路由器都会增加因特网流量的时延，即使客户端与服务器之间没有太多路由器，光速自身也会造成显著的时延。</p> <h3 id="_7-5-命中和未命中的"><a href="#_7-5-命中和未命中的" class="header-anchor">#</a> 7.5 命中和未命中的</h3> <p>缓存无法保存世界上每份文档的副本。可以用已有的副本为某些到达缓存的请求提供服务，称为缓存命中。而没有副本可用，请求仍被转发到原始服务器，称为缓存未命中。</p> <h4 id="_7-5-1-再验证"><a href="#_7-5-1-再验证" class="header-anchor">#</a> 7.5.1 再验证</h4> <p>原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。这种“新鲜度检测”被称为HTTP再验证。</p> <p>缓存可以在任意时刻任意频率进行再验证，但是通常都是在哭护短发起请求之后，才会进行再验证。</p> <p>最常用的HTTP验证工具是If-Modified-Since首部，服务器收到带有这个首部请求之后会发生情况：</p> <ul><li>再验证命中：服务器对象未被修改，会向客户端发送一个小的HTTP 304 Not Modified响应；</li> <li>再验证未命中：服务器对象与缓存副本不同，服务器返回一个普通的带有完整内容的200响应；</li> <li>对象已删除：服务器返回404，缓存也会将副本删除。</li></ul> <h4 id="_7-5-2-文档命中率"><a href="#_7-5-2-文档命中率" class="header-anchor">#</a> 7.5.2 文档命中率</h4> <p>由缓存提供服务的请求所占的比例被称为缓存命中率。缓存的管理者希望命中率接近100%，但是实际得到的命中率会被很多因素影响。对于中等规模的缓存来说，40%命中率是很合理的。</p> <h4 id="_7-5-3-字节命中率"><a href="#_7-5-3-字节命中率" class="header-anchor">#</a> 7.5.3 字节命中率</h4> <p>由于缓存文档大小并不相同，所以文档命中率并不能说明一切。有些大型对象访问次数可能少，但是由于尺寸原因，对整个数据流量的贡献很大，所以有些人更愿意使用字节命中率作为度量值。</p> <p>字节命中率是由缓存提供的字节在传输的所有字节中所占的比例。</p> <p>文档命中率说明组织了多少通往外部网络的事务，提高文档命中率对降低整体延迟很有好处；</p> <p>字节命中率说明了阻止多少字节传向因特网，提高字节命中率对节省带宽很有利。</p> <h4 id="_7-5-4-区分命中和未命中的情况"><a href="#_7-5-4-区分命中和未命中的情况" class="header-anchor">#</a> 7.5.4 区分命中和未命中的情况</h4> <p>对于访问时候命中缓存，客户端收到的响应码都是200。</p> <p>有一种方法可以判断响应是否来自缓存，就是使用Date首部与当前时间进行比较，如果响应中日期较早，客户端通常可以认为是一条缓存的响应。</p> <p>客户端也可以用过Age首部分辨这条响应的使用期。</p> <h3 id="_7-6-缓存的拓扑结构"><a href="#_7-6-缓存的拓扑结构" class="header-anchor">#</a> 7.6 缓存的拓扑结构</h3> <p>缓存有私有缓存与公有代理缓存之分。私有缓存为单个用户专用，公有缓存包含了某个用户群体的常用页面。</p> <p>私有缓存可以做的很小，很便宜，web浏览器中一般有内建的私有缓存，将常用文档缓存在个人电脑的磁盘和内存中。</p> <p>公有缓存是特殊的共享代理服务器，被称为代理缓存，或者缓存代理服务器。它接受多个用户的访问，通过它可以更好地减少冗余流量。</p> <p>缓存有简单的层次结构，也有复杂的网状缓存。简单层次结构中，我们希望大部分用户都能在最近的缓存命中，如果没有命中则去父缓存请求，如图。当代理链路变得很长的时候，性能损耗会变得非常明显。</p> <p>![image-20190625111658240](/Users/wangyunfei/Library/Application Support/typora-user-images/image-20190625111658240.png)</p> <p>网状缓存的对话更为复杂，需要做出动态的缓存通信决策、决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始路由器。这种代理缓存决定选择何种路由对内容进行访问、管理和传送，因此可以将其称为内容路由器。</p> <p>缓存之间更为复杂的关系允许不同组织互为对等实体，将它们的缓存连接起来以实现共赢。提供可选的对等支持缓存被称为兄弟缓存。HTTP并不支持兄弟缓存，所以人们通过一些协议对HTTP进行了扩展，比如因特网缓存协议（ICP），超文本缓存协议（HTCP），详见20章。</p> <h3 id="_7-7-缓存的处理步骤"><a href="#_7-7-缓存的处理步骤" class="header-anchor">#</a> 7.7 缓存的处理步骤</h3> <p>![image-20190625115027003](/Users/wangyunfei/Library/Application Support/typora-user-images/image-20190625115027003.png)</p> <ul><li>（1）接收：缓存从网络中读取抵达的请求报文；</li> <li>（2）解析：对报文进行解析，提取URL和首部，将首部放入易于操作的数据结构；</li> <li>（3）查询：缓存获取了URL，查找本地副本，如果没有就获取一份；</li> <li>（4）新鲜度检测：缓存查看副本是否足够新鲜，如果不是，就询问服务器是否有更新；</li> <li>（5）创建响应：缓存使用新的首部和已缓存的主体来构建一条响应报文；</li> <li>（6）发送：缓存通过网络发送响应给客户端；</li> <li>（7）日志：缓存可选地创建一个日志文件条目来描述这个事务。</li></ul> <h2 id="_8-集成点-网关、隧道及中继"><a href="#_8-集成点-网关、隧道及中继" class="header-anchor">#</a> 8. 集成点：网关、隧道及中继</h2> <h2 id="_9-web机器人"><a href="#_9-web机器人" class="header-anchor">#</a> 9. Web机器人</h2> <h2 id="_10-http-ng"><a href="#_10-http-ng" class="header-anchor">#</a> 10. HTTP-NG</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">3/12/2021, 3:41:20 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/cs/http/qwzn-1.html" class="prev">
        http权威指南：第一部分 Web的基础
      </a></span> <span class="next"><a href="/note/cs/web-cache.html">
        web 缓存
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.359545e8.js" defer></script><script src="/assets/js/2.b5c36d7c.js" defer></script><script src="/assets/js/32.2aee8a1d.js" defer></script>
  </body>
</html>
