<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>http权威指南读书笔记 | Geoffrey&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.png">
    <meta name="description" content="若开始，请至终。">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.67a86999.js" as="script"><link rel="preload" href="/assets/js/2.fdae5db8.js" as="script"><link rel="preload" href="/assets/js/29.b3af6a53.js" as="script"><link rel="prefetch" href="/assets/js/10.4501a5bc.js"><link rel="prefetch" href="/assets/js/11.5995d4c3.js"><link rel="prefetch" href="/assets/js/12.598c37f4.js"><link rel="prefetch" href="/assets/js/13.5b19538d.js"><link rel="prefetch" href="/assets/js/14.6bfe7c84.js"><link rel="prefetch" href="/assets/js/15.dab09a0a.js"><link rel="prefetch" href="/assets/js/16.2470281c.js"><link rel="prefetch" href="/assets/js/17.2f96461f.js"><link rel="prefetch" href="/assets/js/18.e3419046.js"><link rel="prefetch" href="/assets/js/19.cce999d7.js"><link rel="prefetch" href="/assets/js/20.6e4c8097.js"><link rel="prefetch" href="/assets/js/21.578f9692.js"><link rel="prefetch" href="/assets/js/22.c8bb2c2d.js"><link rel="prefetch" href="/assets/js/23.f2b75b28.js"><link rel="prefetch" href="/assets/js/24.bf0f1f7b.js"><link rel="prefetch" href="/assets/js/25.88398bc9.js"><link rel="prefetch" href="/assets/js/26.d309345f.js"><link rel="prefetch" href="/assets/js/27.a802c1ef.js"><link rel="prefetch" href="/assets/js/28.dfeec803.js"><link rel="prefetch" href="/assets/js/3.62656b91.js"><link rel="prefetch" href="/assets/js/30.41aa1ee6.js"><link rel="prefetch" href="/assets/js/31.c4a7c357.js"><link rel="prefetch" href="/assets/js/32.ad16ac25.js"><link rel="prefetch" href="/assets/js/33.92de37bc.js"><link rel="prefetch" href="/assets/js/34.64855c01.js"><link rel="prefetch" href="/assets/js/35.7a7d26d7.js"><link rel="prefetch" href="/assets/js/36.9f346389.js"><link rel="prefetch" href="/assets/js/37.ac5b54f2.js"><link rel="prefetch" href="/assets/js/38.a69b2d3f.js"><link rel="prefetch" href="/assets/js/39.6f62c9c0.js"><link rel="prefetch" href="/assets/js/4.3055d766.js"><link rel="prefetch" href="/assets/js/40.0fa8d2d0.js"><link rel="prefetch" href="/assets/js/41.f8518e29.js"><link rel="prefetch" href="/assets/js/42.89676667.js"><link rel="prefetch" href="/assets/js/43.a1766890.js"><link rel="prefetch" href="/assets/js/44.d2a7ac60.js"><link rel="prefetch" href="/assets/js/45.3ae0658b.js"><link rel="prefetch" href="/assets/js/46.5c744ae0.js"><link rel="prefetch" href="/assets/js/5.a3aaad99.js"><link rel="prefetch" href="/assets/js/6.0c08b555.js"><link rel="prefetch" href="/assets/js/7.ee9c444d.js"><link rel="prefetch" href="/assets/js/8.122d609e.js"><link rel="prefetch" href="/assets/js/9.e89f7a5f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Geoffrey's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  学习笔记
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法学习
</a></div><div class="nav-item"><a href="/fe-interview/" class="nav-link">
  FE-Interview
</a></div> <a href="https://github.com/geoffrey-ne/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  学习笔记
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法学习
</a></div><div class="nav-item"><a href="/fe-interview/" class="nav-link">
  FE-Interview
</a></div> <a href="https://github.com/geoffrey-ne/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/note/javascript/professional-javascript-3/04-var-scope-memory" class="sidebar-heading clickable"><span>JavaScript</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/note/typescript/01-base" class="sidebar-heading clickable"><span>Typescript</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/note/cs/http/qwzn-1" class="sidebar-heading clickable open active"><span>CS</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/note/cs/http/qwzn-1" class="sidebar-heading clickable open active"><span>HTTP</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/cs/http/qwzn-1.html" aria-current="page" class="active sidebar-link">http权威指南：第一部分 Web的基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-1.html#_1-http-概述" class="sidebar-link">1. http 概述</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-1.html#_2-url-与资源" class="sidebar-link">2. URL 与资源</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-1.html#_3-http-报文" class="sidebar-link">3. HTTP 报文</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-1.html#_3-4-状态码" class="sidebar-link">3.4 状态码</a></li><li class="sidebar-sub-header"><a href="/note/cs/http/qwzn-1.html#_4-连接管理" class="sidebar-link">4. 连接管理</a></li></ul></li><li><a href="/note/cs/http/qwzn-2.html" class="sidebar-link">http权威指南：第二部分 HTTP结构</a></li></ul></section></li><li><a href="/note/cs/web-cache.html" class="sidebar-link">web 缓存</a></li><li><a href="/note/cs/linux.html" class="sidebar-link">linux常用指令</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http-权威指南"><a href="#http-权威指南" class="header-anchor">#</a> http 权威指南</h1> <p>todo: 图片需从另一台 pc 同步一下</p> <h1 id="第一部分-http-web-的基础"><a href="#第一部分-http-web-的基础" class="header-anchor">#</a> 第一部分 HTTP： Web 的基础</h1> <h2 id="_1-http-概述"><a href="#_1-http-概述" class="header-anchor">#</a> 1. http 概述</h2> <ul><li>web 客户端和服务器是如何通信的；—— HTTP 协议是载体</li> <li>web 内容资源来自何方；—— 提供资源方为服务器方</li> <li>web 事务是什么，如何工作；—— 事务等于请求+响应</li> <li>HTTP 报文格式；—— 起始行，首部字段，主体</li> <li>底层 TCP 网络传输；—— HTTP 传输内容前需要先建立 TCP/IP 连接</li> <li>HTTP 协议变体；—— 目前广泛使用的版本是 HTTP/1.1</li> <li>web 的架构组件结构；—— 包括缓存，代理，网关，隧道，Agent 代理等</li></ul> <p>疑问？</p> <ul><li>什么是 web 事务——一个事务 = 一个请求 + 一个响应，是指从客户端发送请求到服务器端响应请求的完整过程；</li> <li>协议变体是不是指 https——不是，是指 http 的不同历史版本，现在正在广泛使用的是 HTTP/1.1；</li> <li>web 架构组件是什么？——除客户端及服务端外，其他的 web 组成部分，比如缓存，代理，网关等。</li></ul> <h3 id="_1-1-http-因特网的多媒体信使"><a href="#_1-1-http-因特网的多媒体信使" class="header-anchor">#</a> 1.1 HTTP——因特网的多媒体信使</h3> <p>HTTP 可以将图片、视频、文本、音频等等多媒体资源从世界各处的 web 服务器搬运到 web 浏览器上去；</p> <p>HTTP 是使用可靠的数据传输协议，能够确保数据在传输过程中不被损坏或产生混乱。</p> <h3 id="_1-2-web-服务器和客户端"><a href="#_1-2-web-服务器和客户端" class="header-anchor">#</a> 1.2 web 服务器和客户端</h3> <p>存放 web 内容的就是 web 服务器，而发出请求并接收服务器返回数据的就是 web 客户端，比如浏览器。</p> <p>当客户端发出请求后，服务器处理请求，寻找资源，并将资源对象，对象类型，对象长度及其他信息放在 http 响应中发送给客户端。</p> <h3 id="_1-3-资源"><a href="#_1-3-资源" class="header-anchor">#</a> 1.3 资源</h3> <p>所有类型的来源都是 web 资源，不仅仅包括 web 服务器中的静态文件，数据接口，搜索引擎等。</p> <h4 id="_1-3-1-媒体类型-mime"><a href="#_1-3-1-媒体类型-mime" class="header-anchor">#</a> 1.3.1 媒体类型(MIME)</h4> <p>web 服务器会为所有 HTTP 对象附加 MIME 类型。MIME 是一种文本标记，表示一个主要对象类型和一个特定子类型，比如：</p> <ul><li>HTML 文本文档：text/html</li> <li>普通的 ASCII 文本文档：text/plain</li> <li>GIF 图：image/gif</li></ul> <h4 id="_1-3-2-uri"><a href="#_1-3-2-uri" class="header-anchor">#</a> 1.3.2 URI</h4> <p>URI 统一资源标识符，为 web 服务器所有资源命名。在世界范围内唯一标识。目前 URI 有两种形式：URL 和 URN。</p> <p>URL 统一资源定位符，描述了一台特定服务器上某资源的特定位置。每个 URL 通常包括三个部分：</p> <ul><li>协议方案，比如：http、ftp；</li> <li>服务器因特网地址，比如：www.iqiyi.com</li> <li>服务器上资源地址，比如：/test/image.gif</li></ul> <p>URN 统一资源名，与资源目前的位置无关，资源在任何时间任何位置，通过 URN 都可以定位到。</p> <p>举例：</p> <ul><li>https://www.zhihu.com/question/21950864：URL，指出了资源的具体位置；</li> <li>ftp://example.com/download.zip：URL，虽然使用了不同协议，但同样指出了资源位置；</li> <li>urn:isbn:0-486-27557-4：URN，指定了某本图书，但是没有指定具体位置。</li></ul> <p>URI 是一种概念，旨在为所有 web 资源命名，这样客户端就可以根据自己的需要获取执行资源。而 URL 和 URN 就是这种概念的实现。目前几乎所有 URI 都是 URL。</p> <h3 id="_1-4-事务"><a href="#_1-4-事务" class="header-anchor">#</a> 1.4 事务</h3> <p>一个 HTTP 事务是由一条请求和一个响应结果组成。请求是由客户端发往服务器的，而响应则相反。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190520111319723.png" alt="image-20190520111319723"></p> <h4 id="_1-4-1-方法"><a href="#_1-4-1-方法" class="header-anchor">#</a> 1.4.1 方法</h4> <p>每个 HTTP 请求都包含一个方法，用于告诉服务器要执行什么动作（获取一个 Web 页面，运行一个网关程序，删除一个文件等）。常见的方法有：</p> <ul><li>GET：执行从服务器想客户端发送命名资源；</li> <li>POST：向客户端数据发送到一个指定网关；</li></ul> <p>其它比如：PUT、DELETE、HEAD 等方法，详见第三章。</p> <h4 id="_1-4-2-状态码"><a href="#_1-4-2-状态码" class="header-anchor">#</a> 1.4.2 状态码</h4> <p>每个 HTTP 响应中都包含一个状态码，告知客户端是否成功，或者是否需要采取其它动作。状态码是三位数字，常见状态码有：</p> <ul><li>200：OK，文档正确返回；</li> <li>302：Redirect，重定向，到别的地方去获取资源；</li> <li>404：Not Found， 无法找到这个资源。</li></ul> <p>伴随着每个状态码，HTTP 还会发送解释性“原因短语”文本，比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token number">200</span> OK
<span class="token number">200</span> Success
<span class="token number">200</span> All's cool
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>虽然原因短语不同，但处理过程都是使用状态码，详见第三章。</p> <h4 id="_1-4-3-web-页面可以包含多个对象"><a href="#_1-4-3-web-页面可以包含多个对象" class="header-anchor">#</a> 1.4.3 web 页面可以包含多个对象</h4> <p>应用程序完成一项任务时通常会发布多个 HTTP 事务。比如 web 浏览器会发布一系列 HTTP 事务来获取并显示一个包含了丰富图片的 web 页面。复合 web 页面要为每个嵌入式资源使用一个单独的 HTTP 事务。</p> <h3 id="_1-5-报文"><a href="#_1-5-报文" class="header-anchor">#</a> 1.5 报文</h3> <p>HTTP 报文包括：请求报文(request message)和响应报文(response message)两种类型。报文包括三部分：</p> <ul><li>起始行：第一行，请求中说明要做什么，响应中说明出现什么情况；</li> <li>首部字段：包含一个名字和一个值，以冒号(:)分隔，以空行结束；</li> <li>主体：可选，起始行和首部都是文本格式且都是结构化的，而主体中可以包含任意的二进制数据（比如图片，视频，音轨，软件程序）。</li></ul> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190520114013245.png" alt="image-20190520114013245"></p> <h3 id="_1-6-连接"><a href="#_1-6-连接" class="header-anchor">#</a> 1.6 连接</h3> <p>HTTP 是应用层协议，它不关心网络通信的细节，而是将细节都交给了通用，可靠的传输层协议 TCP/IP。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190520115337051.png" alt="image-20190520115337051"></p> <p>在 HTTP 客户端发送报文之前，需要在客户端与服务器之间建立一条 TCP/IP 连接，而建立连接的方式就是通过服务器 IP 地址及运行软件的端口号定位到 web 服务器。我们来看截个 URL：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>http://207.200.83.29:80/index.html
http://www.netscape.com:80/index.html
http://www.netscape.com/index.html
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第一个 url 直接使用了 ip+端口；</p> <p>第二个使用了域名，就是 IP 的人性化别称，可以通过域名服务（Domain Name Services, DNS）机制方便将域名转换为 IP 地址；</p> <p>第三个简化了端口，因为默认端口为：80，一个基本的浏览器连接处理如图：</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190520120047274.png" alt="image-20190520120047274"></p> <h3 id="_1-7-协议版本"><a href="#_1-7-协议版本" class="header-anchor">#</a> 1.7 协议版本</h3> <ul><li>HTTP/0.9：原型版本，最老版本，只支持 GET，不支持多媒体内容的 MIME 类型、各种 HTTP 首部，或者版本号；很快被 HTTP/1.0 取代；</li> <li>HTTP/1.0：第一个得到广泛使用的版本。增加了版本号，各种 HTTP 首部，额外方法，以及对多媒体对象的处理；</li> <li>HTTP/1.0+：非正式的 HTTP 扩展版本，增加了很多特性，包括持久的 keep-alive，虚拟主机，代理连接等；</li> <li>HTTP/1.1：重点校正 HTTP 设计中的结构性缺陷，明确语义，引入重要的性能优化措施，删除不好的特性。包含了对正在发展中的更复杂的 web 应用程序和部署方式的支持。是当前使用的 http 版本(2.0 之前)；</li> <li>HTTP-NG（又名 HTTP/2.0）：重点关注性能的大幅优化，以及更强大的服务逻辑远程执行框架。</li></ul> <h3 id="_1-8-web-的结构组件"><a href="#_1-8-web-的结构组件" class="header-anchor">#</a> 1.8 web 的结构组件</h3> <ul><li>代理：客户端与服务器之间的 HTTP 中间实体，可以对请求和响应进行过滤等；</li> <li>缓存：HTTP 的仓库，使常用页面副本可以保存在离客户端更近的地方。详见第七章；</li> <li>网关：连接其他应用程序的特殊 web 服务器；</li> <li>隧道：对 HTTP 通信报文进行盲转发的特殊代理，比如 HTTPS 中的 SSL；</li> <li>Agent 代理：发起自动 HTTP 请求的半智能 web 客户端。</li></ul> <h2 id="_2-url-与资源"><a href="#_2-url-与资源" class="header-anchor">#</a> 2. URL 与资源</h2> <ul><li>URL 语法，以及各种 URL 组件的含义及其所做的工作；</li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token operator">&lt;</span>scheme<span class="token operator">&gt;</span>://<span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>passwd<span class="token operator">&gt;</span>@<span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>port<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>path<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>params<span class="token operator">&gt;</span>?<span class="token operator">&lt;</span>query<span class="token operator">&gt;</span><span class="token comment">#&lt;frag&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>很多 Web 客户端都支持的 URL 快捷方式，包括相对 URL 和自动扩展 URL；——相对 URL 与基础 URL，自动扩展是浏览器做的；</li> <li>URL 编码和字符规则；——URL 使用的是 US-ASCII 码，转义方式%+两个表示 ASCII 码的十六进制数；</li> <li>支持各种因特网信息系统的常见 URL 方案；——各种不同协议；</li> <li>URL 的未来，包括 URN——这种框架可以在对象从一处搬到另一处时，保持稳定的访问名称。——总之不太好实现。。</li></ul> <p>疑问？</p> <ul><li>URL 组件是什么？—— 其实就 URL 的各个组成部分，比如方案、主机名、端口等</li> <li>URL 快捷方式？为什么 URL 还需要自动扩展？——快捷方式其实就是相对 URL，自动扩展其实是浏览器的自动填充功能</li> <li>各种因特网信息系统？——各种不同协议，比如：http,https,ftp,mailto,news,file,telnet,rtsp 等</li></ul> <h3 id="_2-1-浏览因特网资源"><a href="#_2-1-浏览因特网资源" class="header-anchor">#</a> 2.1 浏览因特网资源</h3> <p>HTTP 规范将 URI 作为其资源标识符，供浏览器寻找。但实际上，HTTP 应用程序处理的只是 URI 的子集——URL。关于其中区别，详见 1.3.2。</p> <p>举例：http://www.example.com/path/index.html</p> <p>URL 分以下三部分：</p> <ul><li>第一部分：http 是 URL 方案（scheme）告知客户端怎样访问资源；</li> <li>第二部分：www.example.com 指的是服务器的位置；告知客户端资源位于何处；</li> <li>第三部分：资源路径，说明具体要请求的是哪个资源。</li></ul> <p>除 HTTP 以外，URL 可以指向因特网上的任意资源，比如 E-mail 账户：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>mailto:president@whitehouse.gov
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>或者其他资源：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>ftp://ftp.lots-o-books.com/pub/complete-price-list.xls
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其实，这是由浏览器实现其中细节，让用户可以直接输入 url 就获取指定资源。</p> <h3 id="_2-2-url-的语法"><a href="#_2-2-url-的语法" class="header-anchor">#</a> 2.2 URL 的语法</h3> <p>URL 提供了一种定位网上任意资源的手段，这些资源可以通过各种不同的方案来访问，比如：HTTP、FTP、SMTP 等。大部分 URL 都遵循通用的 URL 语法，这个语法格式由九部分构成：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token operator">&lt;</span>scheme<span class="token operator">&gt;</span>://<span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>password<span class="token operator">&gt;</span>@<span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>port<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>path<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>param<span class="token operator">&gt;</span>?<span class="token operator">&lt;</span>query<span class="token operator">&gt;</span><span class="token comment">#&lt;frag&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中最重要的三部分为方案<code>&lt;scheme&gt;</code>、主机<code>&lt;host&gt;</code>、路径<code>&lt;path&gt;</code>。</p> <h4 id="_2-2-1-方案-使用什么协议"><a href="#_2-2-1-方案-使用什么协议" class="header-anchor">#</a> 2.2.1 方案——使用什么协议</h4> <p>方案规定如何访问指定资源的主要标识符，比如 http。方案组件必须以一个字母符号开始，由第一个&quot;:&quot;符号将其与 URL 其余部分分隔开来。方案名大小写无关。</p> <h4 id="_2-2-2-主机和端口"><a href="#_2-2-2-主机和端口" class="header-anchor">#</a> 2.2.2 主机和端口</h4> <p>URL 主机用于标识因特网上资源位于哪台机器上，而端口则是说明资源在那台机器的什么地方。主机可以是域名也可以是端口，比如，下面两个 URL 就是同一资源：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>http://www.joes-hardware.com:80/index.html
http://161.58.228.45:80/index.html
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>端口组件标识了服务器正在监听的网络端口。对于下层使用了 TCP 协议的 HTTP 来说，默认端口号为 80。</p> <h4 id="_2-2-3-用户名和密码"><a href="#_2-2-3-用户名和密码" class="header-anchor">#</a> 2.2.3 用户名和密码</h4> <p>很多服务器要求输入用户名和密码才会允许用户访问数据。用户名和密码组件需要使用@字符将其与 URL 其余部分分隔开来。用户与密码之前使用“:”分隔。FTP 服务器就是这样一个常见的实例。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>ftp://ftp.prep.ai.mit.edu/pub/gnu
ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>第一个例子就是没有用户名和密码组件。如果 URL 方案要求输入用户名和密码，但没有提供，它通常会插入一个默认值，比如插入一个 anonymous 用户，并发送默认密码（IE：IEUser，Netscape Navigator：mozilla）。</p> <h4 id="_2-2-4-路径及-2-2-5-参数组件"><a href="#_2-2-4-路径及-2-2-5-参数组件" class="header-anchor">#</a> 2.2.4 路径及 2.2.5 参数组件</h4> <p>URL 路径说明了资源位于服务器的什么地方，可以使用“/”将 URL 路径组件划分成一些路径段（这与 linux 文件系统路径一致），每个路径段都可以有自己的参数组件。比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>http://www.joes-hardware.com/hammers<span class="token punctuation">;</span><span class="token assign-left variable">sale</span><span class="token operator">=</span>false/index.html<span class="token punctuation">;</span><span class="token assign-left variable">graphics</span><span class="token operator">=</span>true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个例子中有两个路径段，hammers 和 index.html。hammers 路径段参数 sale，值为 false。index.html 段有参数 graphics，值为 true。</p> <h4 id="_2-2-6-查询字符串"><a href="#_2-2-6-查询字符串" class="header-anchor">#</a> 2.2.6 查询字符串</h4> <p>很多互联网资源，比如数据库服务，都是可以通过提问题或者进行查询来缩小所请求资源类型范围的。举个例子，我们想查询数据库中是否存在：编号为 12731，颜色为蓝色，尺寸为 large 的条目：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>http://www.joes-hardware.com/inventor-check.cgi?item<span class="token operator">=</span><span class="token number">12731</span><span class="token operator">&amp;</span><span class="token assign-left variable">color</span><span class="token operator">=</span>blue<span class="token operator">&amp;</span><span class="token assign-left variable">size</span><span class="token operator">=</span>large
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>查询组件位于&quot;?&quot;之后，查询字符串以一系列“名=值”对出现，名值对之间用“&amp;”分隔。在这个例子中查询组件有三个名值对：item=12731、color=blue、size=large。</p> <h4 id="_2-2-7-片段"><a href="#_2-2-7-片段" class="header-anchor">#</a> 2.2.7 片段</h4> <p>有些资源，比如 HTML，可以进一步划分。为了引用部分资源或资源的一个片段，URL 支持使用片段组件来表示一个资源内部的片段。</p> <p>片段挂在 URL 的右手边，最前面有一个字符“#”，比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>http://www.joes-hardware.com/tools.html<span class="token comment">#drills</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在例子中，片段 drills 引用了服务器上页面/tools.html 中的一部分。</p> <p>HTTP 服务器通常只处理整个资源对象，而不是某个片段，客户端不能将片段传送给服务器。浏览器从服务器获得整个资源之后，会根据片段来显示你感兴趣的那部分资源。</p> <h3 id="_2-3-url-快捷方式"><a href="#_2-3-url-快捷方式" class="header-anchor">#</a> 2.3 URL 快捷方式</h3> <h4 id="_2-3-1-相对-url"><a href="#_2-3-1-相对-url" class="header-anchor">#</a> 2.3.1 相对 URL</h4> <p>相对 URL 是在某资源内部指定另一个资源的缩略方式。相对 URL 是不完整的，需要根据基础 URL 解析出绝对 URL 使用。基础 URL 可以在 html 中使用标记<code>&lt;BASE&gt;</code>显式指定。如果没有指定，则可以将它所属资源的 URL 作为基础。</p> <h4 id="_2-3-2-自动扩展-url"><a href="#_2-3-2-自动扩展-url" class="header-anchor">#</a> 2.3.2 自动扩展 URL</h4> <p>我理解就是浏览器的自动补全，有主机名补全和历史扩展两种，主机名扩展比如输入 iqiyi，自动补全 www 和.com。历史扩展就是从历史记录里读取了。因为是浏览器功能，不深入探讨了。</p> <h3 id="_2-4-各种令人头疼的字符"><a href="#_2-4-各种令人头疼的字符" class="header-anchor">#</a> 2.4 各种令人头疼的字符</h3> <p>URL 是用来统一地命名因特网上所有的资源，这意味着要通过不同协议传送这些资源，所以可以通过任意互联网协议安全传输是很重要的。从设计角度看，URL 需要包括以下几个特点：</p> <ul><li>安全传输：安全传输意味着不能丢失信息。比如电子邮件传输协议（SMTP），会剥去特定的字符。为了避开这些问题，URL 只能使用相对较小的、通用安全字母表中的字符；</li> <li>可读性良好：不可见、不可打印的字符不能在 URL 中使用；</li> <li>完整性：有时可能会希望 URL 中包含除通用的安全字母表之外的二进制数据或字符。因此需要转义机制，能够将不安全的字符编码为安全字符，再进行传输。</li></ul> <h4 id="_2-4-1-url-字符集"><a href="#_2-4-1-url-字符集" class="header-anchor">#</a> 2.4.1 URL 字符集</h4> <p>目前 URL 使用的是 US-ASCII 编码。历史悠久可移植性好。</p> <h4 id="_2-4-2-编码机制"><a href="#_2-4-2-编码机制" class="header-anchor">#</a> 2.4.2 编码机制</h4> <p>亦即转义，用来在 URL 中表示各种不安全的字符。这种转义法包含一个百分号（%），后面跟着两个表示字符 ASCII 码的十六进制数。比如空格，ASCII 码：32(0x20)，URL：http://www.joes-hardware.com/more%20tools.html。</p> <h4 id="_2-4-3-字符限制"><a href="#_2-4-3-字符限制" class="header-anchor">#</a> 2.4.3 字符限制</h4> <p>在 URL 中，有些字符被保留起来，有特殊的含义：</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190522101215509.png" alt="image-20190522101215509"></p> <h2 id="_3-http-报文"><a href="#_3-http-报文" class="header-anchor">#</a> 3. HTTP 报文</h2> <ul><li>报文是如何流动的；——上游下游，流入流出；</li> <li>HTTP 报文的三个组成部分；——起始行，首部字段，主体；</li> <li>请求和响应报文之间的区别；——报文的语法不同；</li> <li>请求报文支持的各种方法；——GET,POST,DELETE,PUT,HEAD,OPTIONS,TRACE；</li> <li>和响应报文一起返回的各种状态码；——一到五；</li> <li>各种各样的 HTTP 首部都是用来做什么的。——这章是个综述吧，详细的需要到各个章节学习。</li></ul> <p>不错不错，正是需要梳理一遍的知识：</p> <ul><li>状态码都是做什么的，好好梳理一下；
<ul><li>1xx：信息性状态码；100 Continue，确认服务器是否接受要发送的实体；</li> <li>2xx：成功状态码；比如 200 OK，202 接受，但不一定已经完成请求；</li> <li>3xx：重定向，301 永久重定向；302 临时重定向；</li> <li>4xx：客户端错误，比如 404 找不到，400 错误请求；</li> <li>5xx：服务器错误，比如 500 服务器内部错误，501 超出服务器能力范围。</li></ul></li> <li>各种各样的首部作用；——比较宽泛，需要到各个章节具体学习，不过至少可以知道分为通用、请求、响应、实体四种首部</li></ul> <h3 id="_3-1-报文流"><a href="#_3-1-报文流" class="header-anchor">#</a> 3.1 报文流</h3> <p>报文流入(inbound)源端服务器，工作完成后流出(outbound)，流向用户 Agent 代理。而所有报文的发送者都在接收者上游(upstream)，所有报文都会向下游(downstream)流动。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190522114532955.png" alt="image-20190522114532955"></p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190522114552291.png" alt="image-20190522114552291"></p> <h3 id="_3-2-报文的组成部分"><a href="#_3-2-报文的组成部分" class="header-anchor">#</a> 3.2 报文的组成部分</h3> <p>HTTP 报文是简单的格式化数据块。每条报文由三部分组成：对报文进行描述的起始行、包含属性的首部快，以及可选的主体部分。</p> <p>起始行和首部都是由行分隔的 ASCII 文本。每行都以一个由两个字符组成的行终止序列作为结束，包括一个回车符，和一个换行符。这个终止序列可以写作 CRLF。虽然规范是这样规定的，但是健壮的应用程序应该可以接受单个换行符作为行的终止。</p> <p>主体中可包含文本或二进制数据，也可以为空。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190522141603901.png" alt="image-20190522141603901"></p> <h4 id="_3-2-1-报文的语法"><a href="#_3-2-1-报文的语法" class="header-anchor">#</a> 3.2.1 报文的语法</h4> <p>所有的 HTTP 报文可以分为两类：请求报文(request message)和响应报文(response message)。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 请求报文 - 语法</span>
<span class="token operator">&lt;</span>method<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>request-URL<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>headers<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>entity-body<span class="token operator">&gt;</span>
<span class="token comment"># 请求报文 - 示例</span>
GET /test/hi-there.txt HTTP/1.1
Accept: text/*
Host: www.joes-hardware.com

<span class="token comment"># 注意首部字段和主体之间有一个空格↑</span>

<span class="token comment"># 响应报文 - 语法</span>
<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>status<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>reason-phrase<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>headers<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>entity-body<span class="token operator">&gt;</span>
<span class="token comment"># 响应报文 - 示例</span>
HTTP/1.1 <span class="token number">200</span> OK
Content-type: text/plain
Content-length: <span class="token number">19</span>

Hi<span class="token operator">!</span> I'm a message<span class="token operator">!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>对各部分的简要描述：</p> <ul><li>方法<code>&lt;method&gt;</code>：客户端希望服务器对资源执行的动作；比如：GET、HEAD 或 POST；</li> <li>请求 URL<code>&lt;request-URL&gt;</code>：资源的 URL 路径组件的完整 URL，可以不包含主机/端口，一般服务器可以假定是自己主机和端口；</li> <li>版本<code>&lt;version&gt;</code>：报文所使用的 HTTP 版本，格式：<code>HTTP/&lt;major&gt;.&lt;minor&gt;</code>；</li> <li>状态码<code>&lt;status-code&gt;</code>：三位数字，用于描述请求过程中所发生的情况；</li> <li>原因短语<code>&lt;reason-phrase&gt;</code>：对状态码的描述，只对人类有意义，机器处理还是按照状态码处理；</li> <li>首部<code>&lt;header&gt;</code>：可以有零到多个首部，每个首部都包含一个名字 加 冒号(😃，然后可选空格，接着是一个值，最后是一个 CRLF。首部是由一个空行（CRLF）结束的。表示首部结束和主体部分开始；</li> <li>主体部分<code>&lt;entity-body&gt;</code>：包含任意数据组成的数据块。</li></ul> <h4 id="_3-2-2-起始行"><a href="#_3-2-2-起始行" class="header-anchor">#</a> 3.2.2 起始行</h4> <p>所有的 HTTP 报文都是以一个起始行作为开始。请求报文的起始行说明要做些什么；响应报文的起始行说明发生了什么。</p> <ul><li>请求行：请求报文的起始行。包含方法、路径、HTTP 版本，由空格分开；</li> <li>响应行：响应报文的起始行。包含 HTTP 版本、状态码、原因短语，由空格分开；</li> <li>方法：告知服务器要干什么，比如 GET 用于获取文档，POST 发送需要处理的数据。除了通用方法外，服务器还可以实现自己的请求方法，这些附加方法是对 HTTP 的扩展，称为扩展方法；</li> <li>状态码：用于告诉客户端发生了什么事。比如 200 代表成功。常见状态码比如 200 代表成功，401 代表未授权，需要用户名和密码，404 代表未找到，服务器找不到 URL 对应的资源。状态码可以根据范围进行分类，如图：</li></ul> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190522155432479.png" alt="image-20190522155432479"></p> <ul><li>原因短语：原因短语和状态码是成对出现的，是状态码的可读版本；</li> <li>版本号：形式 - HTTP/x.y 。为 HTTP 应用程序提供一种将自己所遵循的协议版本告知对方，以便互相了解对方的能力和报文格式；</li></ul> <h4 id="_3-2-3-首部"><a href="#_3-2-3-首部" class="header-anchor">#</a> 3.2.3 首部</h4> <p>HTTP 首部字段给请求和响应报文添加了一些附加信息。本质上说，它们只是一些名/值对的列表。首部可以分出几类，比如通用首部、请求首部、响应首部、实体首部、扩展首部等等。但其实这没什么关系，应用程序可以随意自己发明首部。常见首部示例：</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190522161840676.png" alt="image-20190522161840676"></p> <p>首部延续行是指当首部特别长时，可以另起一行，多出来的每行前面至少要有一个空格或制表符。比如：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>Server: Test Server
	Version <span class="token number">1.0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>其中 <code>Version 1.0</code>就是新行。完整首部是<code>Test Server Version 1.0</code></p> <h4 id="_3-2-4-主体部分"><a href="#_3-2-4-主体部分" class="header-anchor">#</a> 3.2.4 主体部分</h4> <p>HTTP 主体部分是 HTTP 要传输的内容，可以包括很多类型的数字数据：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等。</p> <h4 id="_3-2-5-版本-0-9-的报文"><a href="#_3-2-5-版本-0-9-的报文" class="header-anchor">#</a> 3.2.5 版本 0.9 的报文</h4> <p>HTTP/0.9 报文请求中只包含方法和请求 URL，响应只包含实体，没有版本信息，没有状态码，或原因短语，也没有首部。</p> <h3 id="_3-3-方法"><a href="#_3-3-方法" class="header-anchor">#</a> 3.3 方法</h3> <p>服务器一般不会实现所有方法。如果一台服务要与 HTTP 1.1 兼容，那么只要为其资源实现 GET 方法和 HEAD 方法就可以了。</p> <h4 id="_3-3-1-安全方法"><a href="#_3-3-1-安全方法" class="header-anchor">#</a> 3.3.1 安全方法</h4> <p>GET 和 HEAD 方法都被认为是安全的，意味着使用这些方法的 HTTP 请求都不会产生什么动作。</p> <h4 id="_3-3-2-get-3-3-3-head"><a href="#_3-3-2-get-3-3-3-head" class="header-anchor">#</a> 3.3.2 GET 3.3.3 HEAD</h4> <p>GET 是最常用的方法，通常用于请求服务器发送某个资源。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190523090141856.png" alt="image-20190523090141856"></p> <p>而 HEAD 与 GET 方法行为很类似，但服务器在响应中只返回首部，不会返回实体部分。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190523090155265.png" alt="image-20190523090155265"></p> <p>HEAD 作用：</p> <ul><li>在不获取资源的情况下了解资源的情况；</li> <li>通过查看响应中的状态码，看看某个对象是否存在；</li> <li>通过查看首部，判断资源是否被修改了。</li></ul> <h4 id="_3-3-4-put"><a href="#_3-3-4-put" class="header-anchor">#</a> 3.3.4 PUT</h4> <p>PUT 方法的语义就是服务器用请求的主体部分来创建一个由所请求的 URL 命名的文档。因为允许用户对服务器内容进行修改，所以很多 Web 服务器都要求 PUT 之前，用密码登录。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190523090620974.png" alt="image-20190523090620974"></p> <h4 id="_3-3-5-post"><a href="#_3-3-5-post" class="header-anchor">#</a> 3.3.5 POST</h4> <p>POST 起初是用来向服务器输入数据的。但是实际上，通常用它来支持 HTML 的表单。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190523091048741.png" alt="image-20190523091048741"></p> <h4 id="_3-3-6-trace"><a href="#_3-3-6-trace" class="header-anchor">#</a> 3.3.6 TRACE</h4> <p>TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。TRACE 方法用于诊断，用于验证请求是否如愿穿过了请求/响应链。可以查看代理和其他应用程序对请求产生的影响。</p> <p>TRACE 请求中不能带有实体的主体部分。TRACE 响应的主体包含了响应服务器收到的请求的精确副本。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190523091441334.png" alt="image-20190523091441334"></p> <h4 id="_3-3-7-options"><a href="#_3-3-7-options" class="header-anchor">#</a> 3.3.7 OPTIONS</h4> <p>OPTIONS 方法请求 web 服务器告知其支持的各种功能，可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190523092526515.png" alt="image-20190523092526515"></p> <h4 id="_3-3-8-delete"><a href="#_3-3-8-delete" class="header-anchor">#</a> 3.3.8 DELETE</h4> <p>DELETE 方法让服务器删除请求 URL 所指定的资源。但是客户端无法保证删除操作一定会被执行，因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190523092744944.png" alt="image-20190523092744944"></p> <h4 id="_3-3-9-扩展方法"><a href="#_3-3-9-扩展方法" class="header-anchor">#</a> 3.3.9 扩展方法</h4> <p>HTTP 被设计成字段可扩展的，服务器可以为它所管理的资源实现一些特定的 HTTP 方法。比如提供 LOCK 方法锁定资源，COPY 方法复制资源等等。</p> <h2 id="_3-4-状态码"><a href="#_3-4-状态码" class="header-anchor">#</a> 3.4 状态码</h2> <p>状态码为客户端提供了一种理解事务处理结果的便捷方式。</p> <h4 id="_3-4-1-100-199-信息性状态码"><a href="#_3-4-1-100-199-信息性状态码" class="header-anchor">#</a> 3.4.1 100 ~ 199 —— 信息性状态码</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190531094019588.png" alt="image-20190531094019588"></p> <h5 id="关于-100-continue"><a href="#关于-100-continue" class="header-anchor">#</a> 关于 100 Continue</h5> <p>客户端在向服务器端发送一个实体，并且愿意在发送实体之前等待 100 Continue 响应，那么客户端就要发送一个携带了值为 100 Continue 的 Expect 请求首部。这是一种优化，客户端只有在避免向服务器发送一个无法处理或使用的大实体时，才应该使用 100 Continue。</p> <p>对于客户端而言，即使先发送了 100 Continue 也不应该永远等待服务器响应。超时一定时间之后，应该直接将实体发送过去。</p> <p>对于服务器而言，如果收到一个 100 的请求，它会用 100 Continue 或者错误码进行响应，如果响应之前就收到了实体，则不需要再返回这个状态码，但是读取完实体之后，还是应该返回一个最终状态码。</p> <p>对于代理而言，如果它知道下一跳服务器只能与 HTTP/1.1 之前版本兼容，应该以 417 Expectation Failed 错误进行响应。</p> <h4 id="_3-4-2-200-299-成功状态码"><a href="#_3-4-2-200-299-成功状态码" class="header-anchor">#</a> 3.4.2 200 ~ 299 —— 成功状态码</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190531095117135.png" alt="image-20190531095117135"></p> <ul><li>关于 200 就是最常用的成功状态码；</li> <li>201 主要针对 put 请求，服务器创建实体之后，返回 201 Created 代表已创建资源的；</li> <li>202 代表请求接受了，但是服务器还未真正处理，也不保证服务器会完成这个请求；</li></ul> <h4 id="_3-4-3-300-399-重定向状态码"><a href="#_3-4-3-300-399-重定向状态码" class="header-anchor">#</a> 3.4.3 300 ~ 399 —— 重定向状态码</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610093907139.png" alt="image-20190610093907139"></p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610093927830.png" alt="image-20190610093927830"></p> <p>301 是旧 url 已被永久移除，响应的 Location 首部中包含资源最新的 URL。而 302 是一个临时定位状态码，将来请求仍然使用老的 URL。304 代表响应一个有条件的请求，而最近资源未被修改的话，就可以使用这个状态码说明资源未被修改，带有这个状态码的响应不应该包含实体的主体部分。</p> <h4 id="_3-4-4-400-499-客户端错误状态码"><a href="#_3-4-4-400-499-客户端错误状态码" class="header-anchor">#</a> 3.4.4 400 ~ 499 —— 客户端错误状态码</h4> <p>客户端发送一些服务器无法处理的请求，比如格式错误的请求报文，或者请求一个不存在的 URL。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610095115563.png" alt="image-20190610095115563"></p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610095142264.png" alt="image-20190610095142264"></p> <h4 id="_3-4-5-500-599-服务器错误状态码"><a href="#_3-4-5-500-599-服务器错误状态码" class="header-anchor">#</a> 3.4.5 500 ~ 599 —— 服务器错误状态码</h4> <p>客户端请求有效，但是服务器自身出错。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610095532594.png" alt="image-20190610095532594"></p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610095544605.png" alt="image-20190610095544605"></p> <h3 id="_3-5-首部"><a href="#_3-5-首部" class="header-anchor">#</a> 3.5 首部</h3> <p>首部和方法配合工作，共同决定了客户端和服务器能做什么事情。首部可以分为五个主要类型：</p> <ul><li>通用首部：服务器和客户端都可以使用，比如 Date，每一端都可以用它来说明构建报文的时间；</li> <li>请求首部：请求报文特有，为服务器提供一些额外信息，比如客户端希望接收什么类型数据。例如：Accept: */*，用来告知服务器，客户端接受任意媒体类型；</li> <li>响应首部：服务器端使用，为客户端提供信息。比如 Server: Tiki-Hut/1.0，告知服务器版本；</li> <li>实体首部：用于描述实体部分的首部。比如：Content-Type: text/html; charset=iso-latin-1；</li> <li>扩展首部：非标准首部，应用程序开发者创建，但还未添加到已批准的 HTTP 规范中。</li></ul> <h4 id="_3-5-1-通用首部"><a href="#_3-5-1-通用首部" class="header-anchor">#</a> 3.5.1 通用首部</h4> <p>提供了报文相关的最基本信息。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610100506866.png" alt="image-20190610100506866"></p> <p>HTTP/1.0 引入了第一个允许 HTTP 应用程序缓存对象本地副本的首部，这样就不需要总是直接从服务端获取了。详见第七章。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610100652002.png" alt="image-20190610100652002"></p> <h4 id="_3-5-2-请求首部"><a href="#_3-5-2-请求首部" class="header-anchor">#</a> 3.5.2 请求首部</h4> <p>用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610101420333.png" alt="image-20190610101420333"></p> <h5 id="_1-accept-首部"><a href="#_1-accept-首部" class="header-anchor">#</a> 1. Accept 首部</h5> <p>Accept 首部提供了客户端对返回资源的要求，包括它想要什么，可以使用什么，以及它不想要什么。这样服务器就可以对要发送的内容作出更明智的决定。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610101618892.png" alt="image-20190610101618892"></p> <h5 id="_2-条件请求首部"><a href="#_2-条件请求首部" class="header-anchor">#</a> 2. 条件请求首部</h5> <p>为请求加上某些限制，要求服务器在对请求进行相应之前，确保某个条件为真。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610102151909.png" alt="image-20190610102151909"></p> <h5 id="_3-安全请求首部"><a href="#_3-安全请求首部" class="header-anchor">#</a> 3. 安全请求首部</h5> <p>HTTP 本身支持一种简单的质询/相应认证机制，这会在第 14 章详细讨论。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610102334181.png" alt="image-20190610102334181"></p> <h5 id="_4-代理请求首部"><a href="#_4-代理请求首部" class="header-anchor">#</a> 4. 代理请求首部</h5> <p>第 6 章详细说明代理。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610102420361.png" alt="image-20190610102420361"></p> <h4 id="_3-5-3-响应首部"><a href="#_3-5-3-响应首部" class="header-anchor">#</a> 3.5.3 响应首部</h4> <p>用于说明谁在响应、响应者的功能，及一些与响应相关的一些特殊指令。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610104734058.png" alt="image-20190610104734058"></p> <h5 id="_1-协商首部"><a href="#_1-协商首部" class="header-anchor">#</a> 1. 协商首部</h5> <p>第 17 章讨论了协商，比如服务器上有某文档的法语及德语译稿。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610104940597.png" alt="image-20190610104940597"></p> <h5 id="_2-安全响应首部"><a href="#_2-安全响应首部" class="header-anchor">#</a> 2. 安全响应首部</h5> <p>是安全请求首部的响应侧。14 章会详细讨论。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610105040174.png" alt="image-20190610105040174"></p> <h4 id="_3-5-4-实体首部"><a href="#_3-5-4-实体首部" class="header-anchor">#</a> 3.5.4 实体首部</h4> <p>实体首部可以告知报文的接收者它在对什么进行处理。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610111212469.png" alt="image-20190610111212469"></p> <h5 id="_1-内容首部"><a href="#_1-内容首部" class="header-anchor">#</a> 1. 内容首部</h5> <p>提供了与实体内容有关的特性信息，说明了其类型、尺寸以及处理它所需的其它有用信息。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610111327939.png" alt="image-20190610111327939"></p> <h5 id="_2-实体首部缓存"><a href="#_2-实体首部缓存" class="header-anchor">#</a> 2. 实体首部缓存</h5> <p>第 7 章深入探讨。说明了什么时候进行缓存。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610111420151.png" alt="image-20190610111420151"></p> <h2 id="_4-连接管理"><a href="#_4-连接管理" class="header-anchor">#</a> 4. 连接管理</h2> <ul><li>HTTP 是如何使用 TCP 连接的；——DNS 寻址，三次握手</li> <li>TCP 连接的时延、瓶颈以及存在的障碍；——寻址时延，连接时延，慢启动</li> <li>HTTP 的优化，包括并行连接、keep-alive(持久连接)和管道化连接；</li> <li>管理连接时应该以及不应该做的事情。</li></ul> <p>这章估计和网络知识相关。</p> <h3 id="_4-1-tcp-连接"><a href="#_4-1-tcp-连接" class="header-anchor">#</a> 4.1 TCP 连接</h3> <p>几乎所有的 HTTP 通信都是由 TCP/IP 承载的，客户端可以打开一条 TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。一旦建立连接，客户端和服务器之间交换的报文永远不会丢失、受损或失序。一个简单的连接示例：</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610113731272.png" alt="image-20190610113731272"></p> <h4 id="_4-1-1-tcp-的可靠数据管道"><a href="#_4-1-1-tcp-的可靠数据管道" class="header-anchor">#</a> 4.1.1 TCP 的可靠数据管道</h4> <p>TCP 为 HTTP 提供了一条可靠的比特传输管道，从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来。</p> <h4 id="_4-1-2-tcp-流是分段的-由-ip-分组传送"><a href="#_4-1-2-tcp-流是分段的-由-ip-分组传送" class="header-anchor">#</a> 4.1.2 TCP 流是分段的，由 IP 分组传送</h4> <p>HTTP 传送报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 接收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过网络传输。所有这些工作都是由 TCP/IP 处理的，对于 HTTP 层都是透明的。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610115115279.png" alt="image-20190610115115279"></p> <p>每个 TCP 段都是由 IP 分组承载的，每个 IP 分组都包括：</p> <ul><li>一个 IP 分组首部（通常为 20 字节）；</li> <li>一个 TCP 段首部（通常为 20 字节）；</li> <li>一个 TCP 数据块（0 个或多个字节）。</li></ul> <p>IP 首部包含了源和目的 IP 地址、长度和其它一些标记。TCP 端首部包含 TCP 端口号、控制标记，以及用于数据排序和完整性检查的一些数字值。</p> <h4 id="_4-1-3-保持-tcp-连接的正确运行"><a href="#_4-1-3-保持-tcp-连接的正确运行" class="header-anchor">#</a> 4.1.3 保持 TCP 连接的正确运行</h4> <p>TCP 连接是通过 4 个值来识别的：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token operator">&lt;</span>源IP地址、源端口号、目的IP地址、目的端口号<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这四个值唯一地定义了一条连接，两条不同的 TCP 连接不能拥有四个完全相同的值。</p> <h4 id="_4-1-4-用-tcp-套接字编程"><a href="#_4-1-4-用-tcp-套接字编程" class="header-anchor">#</a> 4.1.4 用 TCP 套接字编程</h4> <p>操作系统提供了一些操纵其 TCP 连接的工具，套接字 API 向 HTTP 程序员隐藏了 TCP 和 IP 的所有细节。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610143703909.png" alt="image-20190610143703909"></p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610143805260.png" alt="image-20190610143805260"></p> <h3 id="_4-2-对-tcp-性能的考虑"><a href="#_4-2-对-tcp-性能的考虑" class="header-anchor">#</a> 4.2 对 TCP 性能的考虑</h3> <p>HTTP 紧挨着 TCP 层，位于其上层，所以 HTTP 事务的性能很大程度上取决于底层 TCP 通道的性能。</p> <h4 id="_4-2-1-http-事务的时延"><a href="#_4-2-1-http-事务的时延" class="header-anchor">#</a> 4.2.1 HTTP 事务的时延</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610144201096.png" alt="image-20190610144201096"></p> <p>HTTP 时延主要原因：</p> <ul><li>DNS 寻址：客户端要根据 URI 确定 Web 服务器的 IP 地址和端口号；</li> <li>三次握手建立连接；</li> <li>因特网传输请求报文，以及服务器处理请求报文都需要时间；</li> <li>服务器响应也需要花费时间。</li></ul> <p>这些时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。</p> <h4 id="_4-2-2-性能聚焦区域"><a href="#_4-2-2-性能聚焦区域" class="header-anchor">#</a> 4.2.2 性能聚焦区域</h4> <ul><li>TCP 连接建立握手；</li> <li>TCP 慢启动拥塞控制；</li> <li>数据聚集的 Nagle 算法；</li> <li>用于捎带确认的 TCP 延迟确认算法；</li> <li>TIME_WAIT 时延和端口耗尽。</li></ul> <p>如果要编写高性能的 HTTP 软件，就应该理解接上面的每一个因素。否则可以跳过。</p> <h4 id="_4-2-3-tcp-连接的握手时延"><a href="#_4-2-3-tcp-连接的握手时延" class="header-anchor">#</a> 4.2.3 TCP 连接的握手时延</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610145432579.png" alt="image-20190610145432579"></p> <p>TCP 连接握手需要经过以下几个步骤：</p> <ul><li>请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组，这个分组设置了特殊的 SYN 标记，说明这是一个连接请求（图 a）；</li> <li>如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个 TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明连接请求已被接受（图 b）；</li> <li>最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（图 c）。现代 TCP 栈都允许客户端在这个确认分组中发送数据。</li></ul> <p>小的 HTTP 事务可能会在 TCP 建立上花费 50%或更多的事件。</p> <h4 id="_4-2-4-延迟确认"><a href="#_4-2-4-延迟确认" class="header-anchor">#</a> 4.2.4 延迟确认</h4> <p>因特网自身无法确保可靠的分组传输，所以 TCP 实现了自己的确认机制来确保数据的成功传输。每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完整的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。</p> <p>由于确认报文很小，所以 TCP 允许在发往相同方向的输出数据分组中对其进行“捎带”。其实就是因为确认报文小，所以在发送确认报文之前，让发送者“等等”看看是否有输出数据可以“捎带”这个小报文，这个等等一般就是一个特定的窗口时间（通常是 100~200 毫秒）内将确认报文放在缓冲区，然后寻找事能够捎带它的输出数据分组。如果这段时间内没有，就将确认信息单独分组传送。</p> <h4 id="_4-2-5-tcp-慢启动"><a href="#_4-2-5-tcp-慢启动" class="header-anchor">#</a> 4.2.5 TCP 慢启动</h4> <p>TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度，这种调谐被称为 TCP 慢启动，用于防止因特网的突然过载和拥塞。</p> <p>TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单说，每成功接收一个分组，发送端就有了发送另外两个分组的权限，每个分组都被确认之后就可以发送四个分组，以此类推。这种方式被称为“打开拥塞窗口”。</p> <p>由于存在这种拥塞控制特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。所以 TTP 中有一些可以复用现存连接的工具。其实就是 HTTP 的”持久连接“。</p> <h4 id="_4-2-6-nagle-算法与-tcp-nodelay"><a href="#_4-2-6-nagle-算法与-tcp-nodelay" class="header-anchor">#</a> 4.2.6 Nagle 算法与 TCP_NODELAY</h4> <p>TCP 有一个数据流接口，应用程序可以放入任意尺寸的数据到 TCP 栈中，即使一次只放一个字节也是可以的。但是不管数据有多小，都至少装载了 40 字节的标记和首部。所以如果 TCP 发送了大量的包含少量数据的分组，网络的性能就会严重下降。</p> <p>Nagle 算法试图在发送一个分组之前，将大量的 TCP 数据绑在一起，以提高网络效率。该算法鼓励发送全尺寸的段。只有当其他分组都被确认之后，Nagle 算法才允许发送非全尺寸的分组，否则就将数据缓存起来。只有当挂起分组被确认或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存数据发送出去。</p> <p>这带来一些 HTTP 性能问题：</p> <ul><li>小的报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延；</li> <li>其次，这与延迟确认之间的交互存在问题。该算法会在确认分组抵达之前阻止数据的发送，但是确认分组自身会被延迟确认算法延迟 100~200 毫秒。</li></ul> <p>HTTP 应用程序常常会在自己的栈中设置 TCP_NODELAY 参数，禁用 Nagle 算法提高性能。如果要这么做，一定要确保会向 TCP 写入大块的数据，这样就不会产生一堆小分组。</p> <h4 id="_4-2-7-time-wait-累积与端口耗尽"><a href="#_4-2-7-time-wait-累积与端口耗尽" class="header-anchor">#</a> 4.2.7 TIME_WAIT 累积与端口耗尽</h4> <p>没细看</p> <h3 id="_4-3-http-连接的处理"><a href="#_4-3-http-连接的处理" class="header-anchor">#</a> 4.3 HTTP 连接的处理</h3> <h4 id="_4-3-1-常被误解的-connection-首部"><a href="#_4-3-1-常被误解的-connection-首部" class="header-anchor">#</a> 4.3.1 常被误解的 Connection 首部</h4> <p>HTTP 的 Connection 首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。Connection 首部可以承载 3 种不同类型的标签：</p> <ul><li>HTTP 首部字段名，列出了只与此连接有关的首部；</li> <li>任意标签值，用于描述此连接的非标准选项；</li> <li>值 close，说明操作完成之后需关闭这条持久连接。</li></ul> <p>如果连接标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去，在将报文转发出去之前，必须删除 Connection 首部列出的所有首部字段。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610162302889.png" alt="image-20190610162302889"></p> <h4 id="_4-3-2-串行事务处理时延"><a href="#_4-3-2-串行事务处理时延" class="header-anchor">#</a> 4.3.2 串行事务处理时延</h4> <p>如果只对连接进行简单的管理，TCP 的性能时延可能会叠加起来。比如一个页面包含 3 个嵌入图片，每个事务都需要串行地建立一条新连接，那么时延和慢启动时延就会叠加起来。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610162625465.png" alt="image-20190610162625465"></p> <p>除了串行加载引入的实际时延之外，有些浏览器在对象加载完毕之前无法获知对象的尺寸，无法在屏幕上显示任何内容。这种时候串行装载对象的进度很正常，但是用户面对的却是一个空白的屏幕。</p> <p>还有几种现存和新兴的方法可以提高 HTTP 的连接性能：</p> <ul><li>并行连接：通过多条 TCP 连接发起并发的 HTTP 请求；</li> <li>持久连接：重用 TCP 连接，以消除连接及关闭时延；</li> <li>管道化连接：通过共享的 TCP 连接发起并发的 HTTP 请求；</li> <li>复用的连接：交替传送请求和响应报文（实验阶段）。</li></ul> <h3 id="_4-4-并行连接"><a href="#_4-4-并行连接" class="header-anchor">#</a> 4.4 并行连接</h3> <p>HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610163515829.png" alt="image-20190610163515829"></p> <h4 id="_4-4-1-并行连接可能会提高页面的加载速度"><a href="#_4-4-1-并行连接可能会提高页面的加载速度" class="header-anchor">#</a> 4.4.1 并行连接可能会提高页面的加载速度</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610163553607.png" alt="image-20190610163553607"></p> <h4 id="_4-4-2-并行连接不一定更快"><a href="#_4-4-2-并行连接不一定更快" class="header-anchor">#</a> 4.4.2 并行连接不一定更快</h4> <ul><li>客户端的网络带宽不足，大部分的时间可能都是用来传送数据的；如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小；</li> <li>打开大量连接会消耗很多内存资源，从而引发自身性能问题。</li></ul> <p>实际上浏览器确实使用了并行连接，但是它们会将并行连接的总数限制为一个较小的值（通常是 4 个）。</p> <h4 id="_4-4-3-并行连接可能让人-感觉-更快一些"><a href="#_4-4-3-并行连接可能让人-感觉-更快一些" class="header-anchor">#</a> 4.4.3 并行连接可能让人”感觉“更快一些</h4> <p>如题。</p> <h3 id="_4-5-持久连接"><a href="#_4-5-持久连接" class="header-anchor">#</a> 4.5 持久连接</h3> <p>非持久连接会在每个事务结束之后关闭，持久连接会在不同事务之间保持打开状态，直到客户端或者服务器决定将其关闭为止。持久连接降低了时延和建立连接的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。</p> <h4 id="_4-5-1-持久连接与并行连接"><a href="#_4-5-1-持久连接与并行连接" class="header-anchor">#</a> 4.5.1 持久连接与并行连接</h4> <p>持久连接与并行连接配合使用可能是最高效的方式。现在，很多 Web 应用程序都会打开少量的并行连接，其中的每一个都是持久连接。持久连接有两种类型：比较老的 HTTP/1.0+ &quot;keep-alive&quot;连接，以及现代的 HTTP/1.1 &quot;presistent&quot;连接。</p> <h4 id="_4-5-2-http-1-0-keep-alive-连接"><a href="#_4-5-2-http-1-0-keep-alive-连接" class="header-anchor">#</a> 4.5.2 HTTP/1.0+ keep-alive 连接</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190610165450677.png" alt="image-20190610165450677"></p> <h4 id="_4-5-3-keep-alive-操作"><a href="#_4-5-3-keep-alive-操作" class="header-anchor">#</a> 4.5.3 Keep-Alive 操作</h4> <p>keep-alive 已经不再使用了，HTTP/1.1 规范中也没有对它的说明了。实现 HTTP/1.0 keep-alive 连接的客户端可以包含 Connection: Keep-Alive 首部请求将一条连接保持在打开状态。如果服务端愿意为下一条请求保持打开状态，就在响应中包含相同的首部，如果响应中没有，客户端就认为服务器不支持 keep-alive。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190611143314715.png" alt="image-20190611143314715"></p> <h4 id="_4-5-4-keep-alive-选项"><a href="#_4-5-4-keep-alive-选项" class="header-anchor">#</a> 4.5.4 Keep-Alive 选项</h4> <p>可以用 Keep-Alive 通用首部调节 keep-alive 的行为。</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>Connection: Keep-Alive
Keep-Alive: <span class="token assign-left variable">max</span><span class="token operator">=</span><span class="token number">5</span>, <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">120</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>timeout 估计了服务器希望将连接保持在活跃状态的时间；max 估计了服务器希望为多少个事务保持此连接的活跃状态。这些都不是一个承诺值。</p> <h4 id="_4-5-5-keep-alive-连接的限制和规则"><a href="#_4-5-5-keep-alive-连接的限制和规则" class="header-anchor">#</a> 4.5.5 Keep-Alive 连接的限制和规则</h4> <ul><li>HTTP/1.0 中，keep-alive 默认不使用，客户端必须发送 Connection: Keep-Alive 请求首部来激活 keep-alive 连接；</li> <li>客户端通过响应报文中是否包含 Connection: Keep-Alive 首部就可以知道服务器发出响应之后是否关闭连接了；</li> <li>只有无需检测连接关闭即可确认报文实体主体部分长度的情况下，才能将连接保持在打开状态，也就是说实体的主体部分必须有正确的 Content-Length；</li> <li>对于代理和网关必须执行 Connection 首部的规则，并在转发之前，删除在 Connection 中命名的所有首部字段以及 Connention 首部自身；严格说不应该与无法确定是否支持 Connection 首部的代理服务器建立 keep-alive 连接，以防止哑代理；</li> <li>除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备。</li></ul> <h4 id="_4-5-6-keep-alive-和哑代理"><a href="#_4-5-6-keep-alive-和哑代理" class="header-anchor">#</a> 4.5.6 Keep-Alive 和哑代理</h4> <p>一些旧的代理不理解 Connection 首部，他们都是盲中继，只是将字节从一个连接转发到另一个连接中去，不对 Connection 首部进行特殊的处理。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190611144807253.png" alt="image-20190611144807253"></p> <p>比如这个过程：</p> <ul><li>(a)中，客户端发送一个 keep-alive 请求，等待响应以确认对方是否认可它的持久连接请求；</li> <li>(b)中，哑代理收到了这条请求，但它并不理解 Connection 首部，只是透传给服务器；</li> <li>HTTP 请求抵达 Web 服务器，服务器收到 Connection: Keep-Alive 首部时，会误以为代理希望进行 keep-alive 对话，对于服务器而言，他同意了 keep-alive 对话，并回送了一个 Connection: Keep-Alive 响应首部；所以服务器以为它与代理正在进行 keep-alive 对话，而代理其实并不识别；</li> <li>哑代理将服务器响应回送给客户端，并将 Connnection: Keep-Alive 首部一起传送过去，客户端看到这个首部，认为代理同意 keep-alive 对话，但其实，代理同样不识别；</li> <li>由于代理不识别 keep-alive，所以它在转发完数据之后，一直等待服务器关闭连接，但是服务器认为代理已经显式地请求它将连接保持在打开状态，所以不会关闭连接。这样代理就会挂在那里等待连接的关闭；</li> <li>(d)中，客户端收到回送响应报文，会立即在 keep-alive 连接上向代理发送另一条请求，而代理并不认为同一条连接上会有其它请求，所以请求会被忽略，浏览器永远得不到响应；</li> <li>这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时，并关闭为止。</li></ul> <p>为避免哑代理，现代的代理都绝不能转发 Connection 首部和所有名字出现在 Connection 值中的首部。</p> <h4 id="_4-5-7-插入-proxy-connection"><a href="#_4-5-7-插入-proxy-connection" class="header-anchor">#</a> 4.5.7 插入 Proxy-Connection</h4> <p>思路是不使用 Connection 首部，而是自定义的 Proxy-Connection，聪明的代理可以理解这个首部并在转发的时候替换为 Connection，达到相同的效果。但是对于多层代理，哑代理问题依然存在。</p> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190612095216763.png" alt="image-20190612095216763"></p> <h4 id="_4-5-8-http-1-1-持久连接"><a href="#_4-5-8-http-1-1-持久连接" class="header-anchor">#</a> 4.5.8 HTTP/1.1 持久连接</h4> <p>HTTP/1.1 逐渐停止了对 keep-alive 支持，用一种名为持久连接(persistent connection)的改进型取代了它。HTTP/1.1 中持久连接是默认激活的，需要应用程序显式地添加一个 Connection: close 首部，将连接关闭。</p> <h4 id="_4-5-9-持久连接的限制和规则"><a href="#_4-5-9-持久连接的限制和规则" class="header-anchor">#</a> 4.5.9 持久连接的限制和规则</h4> <ul><li>发送了 Connection: close 请求首部之后，客户端就无法在那条连接上发送更多请求；</li> <li>只有实体主体部分的长度都和相应的 Content-Length 一致时，或者是用分块传输编码方式编码的，连接才能持久保持；</li> <li>HTTP/1.1 的代理服务器不应该与 HTTP/1.0 客户端建立持久连接；</li> <li>不管 Connection 首部取什么值，HTTP/1.1 设备都可以在任意时刻关闭连接；</li> <li>除非重复发起请求会产生副作用，否则如果在客户端收到完成响应之前连接关闭了，客户端就必须要重新发起请求；</li> <li>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，防止服务器过载。代理因为要支持用户的并发通信，所有如果有 N 个用户试图访问服务器的话，代理最多要维持 2N 条到任意服务器或父代理的连接。</li></ul> <h3 id="_4-6-管道化连接"><a href="#_4-6-管道化连接" class="header-anchor">#</a> 4.6 管道化连接</h3> <p>HTTP/1.1 允许在持久连接上可选的使用请求管道。意思是在响应到达之前，剩余的请求也可以开始发送。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。</p> <ul><li>如果无法确定连接是否是持久的，就不应该使用管道；</li> <li>必须按照与请求相同顺序回送 HTTP 响应；</li> <li>HTTP 客户端要做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求；</li> <li>不应该管道化的方式发送会产生副作用的请求，比如 POST。</li></ul> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190612101948958.png" alt="image-20190612101948958"></p> <h3 id="_4-7-关闭连接的奥秘"><a href="#_4-7-关闭连接的奥秘" class="header-anchor">#</a> 4.7 关闭连接的奥秘</h3> <h4 id="_4-7-1-任意-解除连接"><a href="#_4-7-1-任意-解除连接" class="header-anchor">#</a> 4.7.1 ”任意“解除连接</h4> <p>所有 HTTP 客户端、服务器或代理都可以在任意时刻关闭一条 TCP 传输连接。</p> <h4 id="_4-7-2-content-length-及截尾操作"><a href="#_4-7-2-content-length-及截尾操作" class="header-anchor">#</a> 4.7.2 Content-Length 及截尾操作</h4> <p>每条 HTTP 响应都应该有精确的 Content-Length 首部，用以描述响应主体的尺寸。当实际传输的实体长度与 Content-Length 不匹配时，接收端应该质疑长度的正确性。如果接收端是缓存代理，接收端就不应该缓存这条响应。代理应该原封不动地转发这条报文，而不是试图校正，以维护语义的透明性。</p> <h4 id="_4-7-3-连接关闭容限、重试以及幂等性"><a href="#_4-7-3-连接关闭容限、重试以及幂等性" class="header-anchor">#</a> 4.7.3 连接关闭容限、重试以及幂等性</h4> <p>如果一个事务，不管执行一次还是很多次，得到的结果都相同，这个事务就是幂等的。可以认为除 POST 之前的方法都是幂等的。客户端不应该管道化非幂等请求。大多数浏览器都会在重载一个缓存的 POST 响应时，提供一个对话框，询问用户是否希望再次发起事务处理。</p> <h4 id="_4-7-4-正常关闭连接"><a href="#_4-7-4-正常关闭连接" class="header-anchor">#</a> 4.7.4 正常关闭连接</h4> <p><img src="/Users/wangyunfei/Library/Application%20Support/typora-user-images/image-20190612104325289.png" alt="image-20190612104325289"></p> <p>TCP 连接是双向的，连接的每一端都有一个输入队列和一个输出队列，用于数据的读或写。</p> <h5 id="_1-完全关闭与半关闭"><a href="#_1-完全关闭与半关闭" class="header-anchor">#</a> 1. 完全关闭与半关闭</h5> <p>输入与输出全关闭称为完全关闭，只关闭其中一个称为半关闭。</p> <h5 id="_2-tcp-关闭及重置错误"><a href="#_2-tcp-关闭及重置错误" class="header-anchor">#</a> 2. TCP 关闭及重置错误</h5> <p>关闭连接的输出信道总是很安全的，关闭连接的输入信道比较危险。如果另一端向你已关闭的输入信道发送数据，操作系统就会向另一端的机器回送一条 TCP”连接被对端重置“的报文，大部分操作系统会认为这是很严重的错误，会删除还未读取的缓存数据。</p> <h5 id="_3-正常关闭"><a href="#_3-正常关闭" class="header-anchor">#</a> 3. 正常关闭</h5> <p>HTTP 规范建议，当一端突然要关闭一条连接时，应该”正常地关闭传输连接“，但它并没有说明应该如何去做。</p> <p>想要正常关闭连接的应用程序应该先半关闭其输出信道，然后周期性地检查其输入信道的状态。如果在一定时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">3/12/2021, 3:41:20 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/typescript/03-advance.html" class="prev">
        3. 进阶
      </a></span> <span class="next"><a href="/note/cs/http/qwzn-2.html">
        http权威指南：第二部分 HTTP结构
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.67a86999.js" defer></script><script src="/assets/js/2.fdae5db8.js" defer></script><script src="/assets/js/29.b3af6a53.js" defer></script>
  </body>
</html>
