# 如何理解 vue 本质

vue 本质是将"死"DOM 变"活"。DOM 的结构是什么样的？一次组织好就行了，至于未来的如何更新，全交给逻辑。

如何变活？将需要动态变化的、有逻辑处理的：DOM 本身、DOM 属性 和 事件，全部变成“变量”，其中：

- DOM 本身 —— 组件
- DOM 属性 和 事件 —— 指令

组件 —— 函数式开发思想，即输入什么，造成什么影响，应该输出什么

- 输入（options）
  - props
    - 为什么需要单向数据流
- 组件自己管理自己应该管理的东西

  - 如何安排什么时候去做什么（生命周期，watch）

    - 不同生命周期有什么区别？每个生命周期都能做些什么？
    - 假如这些生命周期少一个行不行，为什么现在的 vue 会选择暴露出这几个生命周期
      - 组件状态的保存：keep-alive
    - watch
      - 当数据改变的时候的逻辑处理

  - 如何获取数据，什么时候更新数据（props，生命周期）
  - 如何处理数据与 DOM、DOM 属性、DOM 事件关系（mvvm）

    - (道)使用指令及模板语法，filter，将 数据|行为 <-> DOM|DOM 属性|DOM 事件 相互绑定
    - (道与术+，函数式，观察者模式)使用计算属性 computed，抽象及语义化数据获取逻辑
      - 聚焦 computed：computed 在实现上做了哪些处理（缓存，以及为什么不用 methods，与 watch 的区别，setter）
    - 虚拟 dom，key 属性的引入

  - 组件的复用
    - (术-)data 为什么会需要一个函数
    - data 新加的 property 为什么没有响应式
    - 为什么 Object.freeze(data)会导致响应式失效
    - (术+)slot：作为一个壳的组件
    - 组件如何被使用，如何被认识（注册组件）
      - 局部注册组件的好处？
  - 组件通信
    - 数据：
      - 父组件传值给子组件（props）
      - 全局数据与该组件通信（vuex）
      - 与祖先节点通信（provide/inject）
    - 事件：
      - emit,on + 自定义事件

- 通用逻辑|配置复用：

  - mixin
  - 自定义指令

- 工程性问题（除了 core 以外的事情）
  - 插件：vue-router、vuex
  - 动态组件
  - 创建一个 vue 项目，webpack 配置，开发环境、测试环境打包、生产环境打包 —— vue-cli

# 待解决疑问

## 指令

为什么会诞生，解决了什么问题？核心职责就是“数据|行为”与 “DOM”的桥梁。

自定义指令就是这种处理 dom 逻辑的复用。

- 指令可以使 DOM 属性变为响应式，如`<span v-bind:title="message">`；（数据 <-> 属性 的相互绑定, bind，class，style）
- 指令可以控制 DOM 的渲染，如`<p v-if="seen">现在你看到我了</p>`；（数据 <-> DOM 的相互绑定，if,for,show）
- 指令可以控制事件，如`<button v-on:click="reverseMessage">反转消息</button>`；（数据|行为 <-> DOM 事件的相互绑定,click）
  - 修饰符：对事件的进一层控制，如阻止事件冒泡`<form v-on:submit.prevent="onSubmit">`；（数据|行为 <-> DOM 事件高阶封装）
- 原创的属性如：key 的作用，model 作用
- 缩写：简化写法，开发者习惯培养(`:`，`on`)

## 为什么 template 只能有一个根节点

## 数据侧

- data 新加的 property 为什么没有响应式
- 数组监听数据变化方法

## DOM 侧

- nextTick
- 自定义组件名为什么需要`kebab-case`或者`PascalCase`的命名方式；

## vue 实例的属性与方法

vue 提供了很多实用的实例的属性与方法，他们都是以`$`开头的。

# 备注

- 道：必不可少，核心
  - mvvm
  - 生命周期
  - 指令
  - watch
- 术+：虽然没有也行，但是有了减少开发者的心智负担，具有一定的抽象和复用逻辑
  - computed
  - slot
- 术-：为了解决问题而被动出现的
