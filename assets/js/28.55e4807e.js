(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{388:function(t,a,e){"use strict";e.r(a);var s=e(45),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue")]),t._v(" "),e("p",[t._v("https://github.com/sudheerj/vuejs-interview-questions")]),t._v(" "),e("h2",{attrs:{id:"_1-data-为什么需要函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-data-为什么需要函数"}},[t._v("#")]),t._v(" 1. data 为什么需要函数")]),t._v(" "),e("p",[t._v("组件是可复用的，组件内的数据应该是相互隔离互不影响的。")]),t._v(" "),e("h2",{attrs:{id:"_2-v-for-和-v-if-为什么不建议一起使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-v-for-和-v-if-为什么不建议一起使用"}},[t._v("#")]),t._v(" 2. v-for 和 v-if 为什么不建议一起使用")]),t._v(" "),e("p",[t._v("v-for 优先级高于 v-if，会对数组中每一项进行判断，如果内容很多但展示的很少的话，会很浪费性能。推荐使用 computed 先过滤。")]),t._v(" "),e("h2",{attrs:{id:"_3-watch-与-computed-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-watch-与-computed-的区别"}},[t._v("#")]),t._v(" 3. watch 与 computed 的区别")]),t._v(" "),e("p",[t._v("细节上：computed 会缓存 getter，只有在依赖数据变化时更新；watch 会传入 newVal 和 oldVal，适合做逻辑处理；使用上：computed 主要是在一个数据变化时更新另一个数据时使用；watch 主要是在一个数据变化时处理一些事情。")]),t._v(" "),e("h2",{attrs:{id:"_4-vue-生命周期及对应的行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-生命周期及对应的行为"}},[t._v("#")]),t._v(" 4. vue 生命周期及对应的行为")]),t._v(" "),e("ul",[e("li",[t._v("beforecreated：$el 和 data 并未初始化，不要修改 data，因为拿不到；")]),t._v(" "),e("li",[t._v("created:完成了 data 数据的初始化， $ el 没有 （初始化 data 的操作应该放在 created 而不是 beforeCreated）")]),t._v(" "),e("li",[t._v("beforeMount：完成了 $el 和 data 初始化，有了 render function 的时候才会执行")]),t._v(" "),e("li",[t._v("mounted ：完成挂载")])]),t._v(" "),e("p",[t._v("关于生命周期用法：")]),t._v(" "),e("ul",[e("li",[t._v("beforecreate : 举个栗子：可以在这加个 loading 事件")]),t._v(" "),e("li",[t._v("created ：在这结束 loading，还做一些初始化，实现函数自执行")]),t._v(" "),e("li",[t._v("mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情")]),t._v(" "),e("li",[t._v("beforeDestroy： 你确认删除 XX 吗？ destroyed ：当前组件已被删除，清空相关内容")])]),t._v(" "),e("h2",{attrs:{id:"_5-父子组件生命周期顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-父子组件生命周期顺序"}},[t._v("#")]),t._v(" 5. 父子组件生命周期顺序")]),t._v(" "),e("p",[t._v("父组件 beforeCreated 父组件 created 父组件 beforeMounted 子组件 beforeCreated 子组件 created 子组件 beforeMounted 子组件 mounted 父组件 mounted")]),t._v(" "),e("p",[t._v("子组件优于父组件先 mounted。")]),t._v(" "),e("h2",{attrs:{id:"_6-vue-组件间通讯方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-组件间通讯方法"}},[t._v("#")]),t._v(" 6. vue 组件间通讯方法")]),t._v(" "),e("ul",[e("li",[t._v("父子主要通过：props、emit")]),t._v(" "),e("li",[t._v("全局管理：eventBus，vuex")]),t._v(" "),e("li",[t._v("其他：provide / inject，$parent / $children")])]),t._v(" "),e("h2",{attrs:{id:"_7-如何实现自定义指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何实现自定义指令"}},[t._v("#")]),t._v(" 7. 如何实现自定义指令")]),t._v(" "),e("p",[t._v("钩子函数：")]),t._v(" "),e("ul",[e("li",[t._v("bind：只调用一次，在第一次绑定元素时调用，初始化设置(el, binding)；")]),t._v(" "),e("li",[t._v("inserted：插入父节点时调用(仅保证父节点存在，但不一定已被插入文档中)；")]),t._v(" "),e("li",[t._v("update：vnode 更新时调用；")]),t._v(" "),e("li",[t._v("componentUpdated：vnode 及子 vnode 都更新后调用；")]),t._v(" "),e("li",[t._v("unbind：只调用一次，解绑时调用。")])]),t._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("directive")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'lazyload'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指令的定义")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("bind")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("el"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" binding")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" lazyImageObserver "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntersectionObserver")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("entries"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" observer")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      entries"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("entry"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" lazyImage "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" entry"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 相交率，默认是相对于浏览器视窗")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("entry"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("intersectionRatio "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          lazyImage"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("src "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" binding"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value\n          "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前图片加载完之后需要去掉监听")]),t._v("\n          lazyImageObserver"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("unobserve")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lazyImage"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    lazyImageObserver"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br")])]),e("p",[t._v("bind: 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted: 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated: 指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind: 只调用一次，指令与元素解绑时调用。")]),t._v(" "),e("h2",{attrs:{id:"_8-nexttick-实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-nexttick-实现原理"}},[t._v("#")]),t._v(" 8. nextTick 实现原理")]),t._v(" "),e("p",[t._v("当数据更新了，在 dom 中渲染后，自动执行该函数。使用 nextTick 保证当前视图渲染完成。")]),t._v(" "),e("ul",[e("li",[t._v("调用 nextTick 时，会把方法存入数组中 callbacks；")]),t._v(" "),e("li",[t._v("判断是否 pending（等待执行）中，否 -> 执行 timeFunc -> 使用 timeFunc 异步执行 callbacks 中的方法，执行结束之后清空数组，设置 pengding 为 false；")]),t._v(" "),e("li",[t._v("timeFunc 用于判断用什么执行异步\n"),e("ul",[e("li",[t._v("优先判断 promise；")]),t._v(" "),e("li",[t._v("不支持 promise 的使用 MutationObserver(可以监控 DOM 变化，并且是异步更新)")]),t._v(" "),e("li",[t._v("否则判断 setImmediate")]),t._v(" "),e("li",[t._v("否则使用 setTimeout")])])])]),t._v(" "),e("h2",{attrs:{id:"_9-vue3-为什么不用-defineproperty-了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue3-为什么不用-defineproperty-了"}},[t._v("#")]),t._v(" 9. vue3 为什么不用 defineProperty 了")]),t._v(" "),e("p",[t._v("defineProperty 缺点：")]),t._v(" "),e("ul",[e("li",[t._v("对于数组，不能通过数组下标来观测其变化，也不能观测数组长度 length 的变化；")]),t._v(" "),e("li",[t._v("不能检测对象属性的添加或删除；")])]),t._v(" "),e("p",[t._v("proxy 可以完美解决以上问题，但是 proxy 自身也有问题：")]),t._v(" "),e("ul",[e("li",[t._v("Proxy 代理的对象只能代理到第一层，多层需要递归监听；")]),t._v(" "),e("li",[t._v("Proxy 代理对象是数组时，比如 push 操作会触发多次 get/set ，因为 push 操作除了增加数组的数据项之外，也会引发数组本身其他相关属性的改变，因此会多次触发 get/set；")])]),t._v(" "),e("p",[t._v("解决方案：")]),t._v(" "),e("ul",[e("li",[t._v("判断 key 是否为新增属性，是就 trigger；")]),t._v(" "),e("li",[t._v("判断旧值与新值是否相等，是就 trigger;")])]),t._v(" "),e("h2",{attrs:{id:"_10-vue-diff"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-diff"}},[t._v("#")]),t._v(" 10. vue diff")]),t._v(" "),e("ul",[e("li",[t._v("先找相同，左左，右右；")]),t._v(" "),e("li",[t._v("没有再找只需移动的，左右右左；")]),t._v(" "),e("li",[t._v("没有则根据新 key 在旧 key 表中查找，找到了并且相同，则移动到旧头前，否则新建；")]),t._v(" "),e("li",[t._v("最后如果旧的遍历完了，则新的全部新建；如果新的遍历完了，则旧的全删除；")])]),t._v(" "),e("h2",{attrs:{id:"_11-try-files、proxy-pass、rewrite"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-try-files、proxy-pass、rewrite"}},[t._v("#")]),t._v(" 11. try_files、proxy_pass、rewrite")]),t._v(" "),e("ul",[e("li",[t._v("try_files 为依次尝试路径，一般最后接的是肯定能满足的，比如 index.html，配合 vue 必须先访问到 html 才能生效前端路由使用；")]),t._v(" "),e("li",[t._v("proxy_pass 一般是把请求转发至代理响应，不改变浏览器 url；")]),t._v(" "),e("li",[t._v("rewrite 根据正则替换路径，会改变 url 地址；")])]),t._v(" "),e("h2",{attrs:{id:"_12-使用数组索引作为-key-为什么是一种反优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-使用数组索引作为-key-为什么是一种反优化"}},[t._v("#")]),t._v(" 12. 使用数组索引作为 key 为什么是一种反优化")]),t._v(" "),e("p",[t._v("判断两个 vnode 是否相同，第一个就是判断两个 vnode 的 key 值是否相同")]),t._v(" "),e("ul",[e("li",[t._v("使用数组索引作为 key，当数组改变时，key 的值无法表现出实际改变，与未标记 key 值的效果一致；")]),t._v(" "),e("li",[t._v("key 值还会用于保存 dom 的状态，如果 key 值无法体现实际改变，可能会引起状态串行问题；")])]),t._v(" "),e("p",[t._v("参考：https://segmentfault.com/a/1190000019961419")]),t._v(" "),e("h2",{attrs:{id:"new-vue-做了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-vue-做了什么"}},[t._v("#")]),t._v(" new Vue 做了什么")]),t._v(" "),e("h2",{attrs:{id:"compose-api-和-react-hook-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#compose-api-和-react-hook-区别"}},[t._v("#")]),t._v(" compose api 和 react hook 区别")]),t._v(" "),e("ul",[e("li",[t._v("vue 的 setup 只执行一次，react hook 一般是写在函数式组件中，最终被转换为"),e("code",[t._v("React.createElement")]),t._v("，每次渲染都会执行")]),t._v(" "),e("li",[t._v("React 严格限制 Hook 的执行顺序和禁止条件调用")])]),t._v(" "),e("h2",{attrs:{id:"keep-alive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" keep-alive")])])}),[],!1,null,null,null);a.default=n.exports}}]);