(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{422:function(e,t,v){"use strict";v.r(t);var _=v(45),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue-源码阅读笔记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-源码阅读笔记"}},[e._v("#")]),e._v(" vue 源码阅读笔记")]),e._v(" "),v("h2",{attrs:{id:"声明-vue-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#声明-vue-类"}},[e._v("#")]),e._v(" 声明 Vue 类")]),e._v(" "),v("p",[e._v("顺序：")]),e._v(" "),v("ul",[v("li",[e._v("src/platforms/web/entry-runtime-with-compiler.js - 具备 compiler")]),e._v(" "),v("li",[e._v("src/platforms/web/runtime/index.js - 绑定与平台相关的特性")]),e._v(" "),v("li",[e._v("src/core/index.js - 绑定核心方法")])]),e._v(" "),v("p",[e._v("这三个步骤绑定了 vue 的核心方法 + vue 根据不同平台所具有的特性。如果仅为 runtime 到上一个文件就够了，这个文件还包括将 template 转换为 render 方法的 compliler 部分。")]),e._v(" "),v("h3",{attrs:{id:"src-core-index-js"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#src-core-index-js"}},[e._v("#")]),e._v(" src/core/index.js")]),e._v(" "),v("h4",{attrs:{id:"声明-vue-向原型上绑定一些全局方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#声明-vue-向原型上绑定一些全局方法"}},[e._v("#")]),e._v(" 声明 Vue，向原型上绑定一些全局方法")]),e._v(" "),v("p",[e._v("初始化"),v("code",[e._v("function Vue (options) {}")]),e._v("后，开始向"),v("code",[e._v("Vue")]),e._v("的原型上绑定方法。")]),e._v(" "),v("ul",[v("li",[e._v("initMixin：初始化方法"),v("code",[e._v("_init")]),e._v("；")]),e._v(" "),v("li",[e._v("stateMixin：数据相关"),v("code",[e._v("$data")]),e._v("、"),v("code",[e._v("$props")]),e._v("、"),v("code",[e._v("$set")]),e._v("、"),v("code",[e._v("$delete")]),e._v("、"),v("code",[e._v("$watch")]),e._v("；")]),e._v(" "),v("li",[e._v("eventsMixin：事件相关"),v("code",[e._v("$on")]),e._v("、"),v("code",[e._v("$once")]),e._v("、"),v("code",[e._v("$once")]),e._v("、"),v("code",[e._v("$off")]),e._v("；")]),e._v(" "),v("li",[e._v("lifecycleMixin：生命周期相关"),v("code",[e._v("_update")]),e._v("、"),v("code",[e._v("$forceUpdate")]),e._v("、"),v("code",[e._v("$destroy")]),e._v("；")]),e._v(" "),v("li",[e._v("renderMixin：render 相关："),v("code",[e._v("nextTick")]),e._v("、"),v("code",[e._v("_render")]),e._v("；")])]),e._v(" "),v("h4",{attrs:{id:"initglobalapi-向-vue-本身添加一些属性和方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#initglobalapi-向-vue-本身添加一些属性和方法"}},[e._v("#")]),e._v(" initGlobalAPI，向 Vue 本身添加一些属性和方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Vue.util")]),e._v("、"),v("code",[e._v("set")]),e._v("、"),v("code",[e._v("delete")]),e._v("、"),v("code",[e._v("nextTick")]),e._v("、"),v("code",[e._v("observable")]),e._v("、"),v("code",[e._v("options")]),e._v("、"),v("code",[e._v("use")]),e._v("、"),v("code",[e._v("mixin")]),e._v("、"),v("code",[e._v("extends")]),e._v("、asset 相关方法")])]),e._v(" "),v("h4",{attrs:{id:"isserver-ssrcontext-functionalrendercontext-version"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#isserver-ssrcontext-functionalrendercontext-version"}},[e._v("#")]),e._v(" $isServer & $ssrContext & FunctionalRenderContext & version")]),e._v(" "),v("p",[e._v("全局标记")]),e._v(" "),v("h3",{attrs:{id:"src-platforms-web-runtime-index-js"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#src-platforms-web-runtime-index-js"}},[e._v("#")]),e._v(" src/platforms/web/runtime/index.js")]),e._v(" "),v("p",[e._v("core/index.js 核心方法绑定完之后，开始根据平台绑定不同方法。")]),e._v(" "),v("ul",[v("li",[e._v("Vue.config: "),v("code",[e._v("mustUseProp")]),e._v("、"),v("code",[e._v("isReservedTag")]),e._v("、"),v("code",[e._v("isReservedAttr")]),e._v("、"),v("code",[e._v("getTagNamespace")]),e._v("、"),v("code",[e._v("isUnknownElement")]),e._v(";")]),e._v(" "),v("li",[e._v("扩展"),v("code",[e._v("directives")]),e._v("，增加平台特有的"),v("code",[e._v("platformDirectives")]),e._v("；")]),e._v(" "),v("li",[e._v("扩展"),v("code",[e._v("components")]),e._v("，增加平台特有的"),v("code",[e._v("platformComponents")]),e._v("；")]),e._v(" "),v("li",[e._v("增加"),v("code",[e._v("__patch__")]),e._v(" 和 "),v("code",[e._v("$mounted")]),e._v("方法；")]),e._v(" "),v("li",[e._v("如果是浏览器环境，还会检查"),v("code",[e._v("devtools")]),e._v("。")])]),e._v(" "),v("h3",{attrs:{id:"src-platforms-web-entry-runtime-with-compiler-js"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#src-platforms-web-entry-runtime-with-compiler-js"}},[e._v("#")]),e._v(" src/platforms/web/entry-runtime-with-compiler.js")]),e._v(" "),v("p",[e._v("然后用户就要使用这个 VUE 类啦")]),e._v(" "),v("h2",{attrs:{id:"初始化-new-vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初始化-new-vue"}},[e._v("#")]),e._v(" 初始化 new Vue")]),e._v(" "),v("h3",{attrs:{id:"init-this-init-options"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#init-this-init-options"}},[e._v("#")]),e._v(" init（"),v("code",[e._v("this._init(options)")]),e._v("）")]),e._v(" "),v("p",[e._v("入口：src/core/instance/index.js")]),e._v(" "),v("h4",{attrs:{id:"merge-options-初始化-合理化-options"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#merge-options-初始化-合理化-options"}},[e._v("#")]),e._v(" merge options（初始化 & 合理化 options）")]),e._v(" "),v("p",[e._v("处理传入的 Options，和父级、extends、mixin 的 options 做合并。")]),e._v(" "),v("p",[e._v("正常合并调用"),v("code",[e._v("mergeOptions(parent: 父组件的options, child: 当前options, vm)")]),e._v("（"),v("code",[e._v("vm._isComponent")]),e._v(" 为选项为 true 的被特殊处理）")]),e._v(" "),v("p",[e._v("mergeOptions，合并 parent 和 child 的配置：")]),e._v(" "),v("ul",[v("li",[v("ol",[v("li",[e._v("先检验"),v("code",[e._v("components")]),e._v("选项命名，不满足时 warning")])]),e._v(" "),v("ul",[v("li",[e._v("满足 html5 规范；")]),e._v(" "),v("li",[e._v("非内置标签（slot,component）、非 html 标签、非 svg 标签")])])]),e._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[e._v("当前 child 为函数时，child = child.options")])])]),e._v(" "),v("li",[v("ol",{attrs:{start:"3"}},[v("li",[e._v("normalize")])]),e._v(" "),v("ul",[v("li",[e._v("normalizeProps: 处理 props\n"),v("ul",[v("li",[e._v("将所有非 Object-based 的 props 都转换为 object")]),e._v(" "),v("li",[e._v("命名全部保存为驼峰写法")]),e._v(" "),v("li",[e._v("支持格式：字符串数组；对象，值可以是对象也可以是 type 的值")]),e._v(" "),v("li",[e._v("否则 warning")]),e._v(" "),v("li",[e._v("替换 props 为新值 options.props = res")])])]),e._v(" "),v("li",[e._v("normalizeInject: 把所有 inject 改为 object 形式")]),e._v(" "),v("li",[e._v("normalizeDirectives: 直接定义为 function 的指令格式化为 object 形式")])])]),e._v(" "),v("li",[v("ol",{attrs:{start:"4"}},[v("li",[e._v("extends 和 mixin 的选项都递归合并到 parent 上")])])]),e._v(" "),v("li",[v("ol",{attrs:{start:"5"}},[v("li",[e._v("按照合并策略进行合并")])]),e._v(" "),v("ul",[v("li",[e._v("默认合并策略：当前有配置就用当前的，没有就用 parent 的")]),e._v(" "),v("li",[e._v("生命周期\n"),v("ul",[v("li",[e._v("调用 mergeHook 合并为数组： parent 的 hook 在数组前面，child 的 hook 放在后面(parentVal.concat(childVal))")]),e._v(" "),v("li",[e._v("有数组去重操作")])])]),e._v(" "),v("li",[v("code",[e._v("['component', 'directive', 'filter']")]),e._v("被归为 assets，使用 mergeAssets 合并")]),e._v(" "),v("li",[v("code",[e._v("props、methods、inject、computed")]),e._v("统一合并策略")]),e._v(" "),v("li",[v("code",[e._v("watch")]),e._v("单独合并策略")])])])]),e._v(" "),v("h4",{attrs:{id:"init-initlifecycle、initevents、initrender"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#init-initlifecycle、initevents、initrender"}},[e._v("#")]),e._v(" init（initLifecycle、initEvents、initRender）")]),e._v(" "),v("p",[e._v("initProxy")]),e._v(" "),v("p",[e._v("没看")]),e._v(" "),v("p",[e._v("initLifecycle")]),e._v(" "),v("p",[e._v("处理生命周期。")]),e._v(" "),v("ul",[v("li",[e._v("配置父子关系相关的变量\n"),v("ul",[v("li",[e._v("先找到第一个非抽象的父节点，并添加示例到父节点的 children 中。"),v("code",[e._v("parent.$children.push(vm)")]),e._v("；")]),e._v(" "),v("li",[e._v("配置实例的父节点。"),v("code",[e._v("vm.$parent = parent")])]),e._v(" "),v("li",[e._v("配置 root；")])])]),e._v(" "),v("li",[e._v("配置了一堆跟生命周期相关的变量；")])]),e._v(" "),v("p",[e._v("initEvents")]),e._v(" "),v("ul",[v("li",[e._v("初始化"),v("code",[e._v("_events")]),e._v("为空对象")]),e._v(" "),v("li",[v("code",[e._v("_hasHookEvent")]),e._v("配置为 false")]),e._v(" "),v("li",[v("code",[e._v("_parentListeners")]),e._v(" 不知道干嘛的")])]),e._v(" "),v("p",[e._v("initRender")]),e._v(" "),v("ul",[v("li",[e._v("初始化"),v("code",[e._v("_vnode")]),e._v("，作为虚拟 dom 的根节点")]),e._v(" "),v("li",[e._v("其他的没看明白")])]),e._v(" "),v("h4",{attrs:{id:"callhook-vm-beforecreate"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#callhook-vm-beforecreate"}},[e._v("#")]),e._v(" callHook(vm, 'beforeCreate')")]),e._v(" "),v("p",[e._v("所以 beforeCreate 触发的时候，只做了处理 options 和 init 的操作。")]),e._v(" "),v("p",[e._v("所以此时，还拿不到 props | methods | data | computed | watch 这些")]),e._v(" "),v("h4",{attrs:{id:"initinjections-initprovide"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#initinjections-initprovide"}},[e._v("#")]),e._v(" initInjections | initProvide")]),e._v(" "),v("p",[e._v("处理 data/props 前，处理 inject;")]),e._v(" "),v("p",[e._v("处理 data/props 后，处理 provide。")]),e._v(" "),v("h4",{attrs:{id:"initstate-props-methods-data-computed-watch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#initstate-props-methods-data-computed-watch"}},[e._v("#")]),e._v(" initState（props | methods | data | computed | watch）")]),e._v(" "),v("p",[e._v("处理 props | methods | data | computed | watch。")]),e._v(" "),v("ul",[v("li",[e._v("props：defineReactive")]),e._v(" "),v("li",[e._v("methods：合理的 methods 绑到 vm 实例上")]),e._v(" "),v("li",[e._v("data：调用 data 方法拿到 data，并绑到 vm 上。observe data 本身")]),e._v(" "),v("li",[e._v("computed：先初始化 data 再初始化 computed。使用 defineProperty 将 computed 对应的 key 绑到 vm 上\n"),v("ul",[v("li",[e._v("!isServerRendering 的 computed 属性都有缓存，即为每一个 computed 都定义一个 Watcher；")]),e._v(" "),v("li",[e._v("缓存就是指使用了 watcher，只有 watcher 为 dirty 时才会主动更新")])])]),e._v(" "),v("li",[e._v("watch：使用 vm.$watch 创建监听")])]),e._v(" "),v("p",[e._v("computed 和 watch 底层都是使用了"),v("code",[e._v("Watch")]),e._v("，不同的是：")]),e._v(" "),v("ul",[v("li",[e._v("computed 在监听的数据更新时，更新了 watch 的 dirty 为 true，在调用 getter 时更新数据，并通知监听者")]),e._v(" "),v("li",[e._v("watch 主要在监听数据更新时，执行操作方法，方法可以获取到 oldVal,newVal")])]),e._v(" "),v("h4",{attrs:{id:"callhook-vm-created"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#callhook-vm-created"}},[e._v("#")]),e._v(" callHook(vm, 'created')")]),e._v(" "),v("p",[e._v("所以 created 已经可以拿到数据和方法（props | methods | data | computed | watch）了。但是还拿不到"),v("code",[e._v("$el")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"mounted-vm-mount-vm-options-el"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mounted-vm-mount-vm-options-el"}},[e._v("#")]),e._v(" mounted （"),v("code",[e._v("vm.$mount(vm.$options.el)")]),e._v("）")]),e._v(" "),v("p",[e._v("如果配置了"),v("code",[e._v("vm.$options.el")]),e._v("，则执行 mount（"),v("code",[e._v("mountComponent")]),e._v("）。")]),e._v(" "),v("ul",[v("li",[e._v("入口：src/core/instance/lifecycle.js")])]),e._v(" "),v("h4",{attrs:{id:"callhook-vm-beforemount"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#callhook-vm-beforemount"}},[e._v("#")]),e._v(" callHook(vm, 'beforeMount')")]),e._v(" "),v("p",[e._v("beforeMount 较于 created 仅仅做了一个绑定$el("),v("code",[e._v("vm.$el = el")]),e._v(")，和 render 校验。")]),e._v(" "),v("p",[e._v("mountComponent 核心就是调用了比较熟知的"),v("code",[e._v("patch")]),e._v("方法。具体详见 patch 说明")]),e._v(" "),v("p",[e._v("patch 会递归创建子节点，子节点创建成功后(vnode 不为空)，会触发"),v("code",[e._v("callHook(vm, 'mounted')")]),e._v("，然后继续创建父节点，所以父节点的 mounted 要晚于子节点，顺序为：")]),e._v(" "),v("ul",[v("li",[e._v("父组件 beforeCreated 父组件 created 父组件 beforeMounted （此时父组件的 patch 会触发创建子组件）")]),e._v(" "),v("li",[e._v("子组件 beforeCreated 子组件 created 子组件 beforeMounted")]),e._v(" "),v("li",[e._v("子组件 mounted -> 父组件 mounted(所有子组件均 mounted 之后)")])]),e._v(" "),v("h2",{attrs:{id:"内部-双向绑定说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内部-双向绑定说明"}},[e._v("#")]),e._v(" （内部）双向绑定说明")]),e._v(" "),v("p",[e._v("在组件 mount 之前，会调用新建一个 watcher，watcher 执行 get 时，配置了"),v("code",[e._v("Dep.target = this")]),e._v("（当前 watcher），而后调用"),v("code",[e._v("updateComponent")]),e._v("，触发 render，render 在获取数据值时，触发了数据的 get 方法收集依赖。")]),e._v(" "),v("p",[e._v("所以当数据改变时，会重新触发"),v("code",[e._v("updateComponent")]),e._v("，调用"),v("code",[e._v("render")]),e._v("更新 vnode，调用"),v("code",[e._v("__patch__")]),e._v("做 diff 后更新视图。")]),e._v(" "),v("h3",{attrs:{id:"watcher"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watcher"}},[e._v("#")]),e._v(" watcher")]),e._v(" "),v("p",[e._v("属性说明：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("lazy：lazy 就是给 computed 用的")]),e._v(" "),v("ul",[v("li",[e._v("当数据更新时，配置为 lazy 的 watcher 会将 dirty 属性设置为 true；")]),e._v(" "),v("li",[e._v("当执行 computed 的 getter 时，会判断这个 wathcer 的 dirty 属性是否为 true，如果不是，相当于命中缓存，不再重新执行，否则执行 watcher.evaluate 更新数据")])])])]),e._v(" "),v("h4",{attrs:{id:"关于-watcher-的执行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于-watcher-的执行"}},[e._v("#")]),e._v(" 关于 watcher 的执行")]),e._v(" "),v("ul",[v("li",[e._v("lazy: lazy 的 watcher 是给 computed 用的，当数据更新时被标记 dirty 为 true，当执行 computed 的 getter 时执行 watcher；\n"),v("ul",[v("li",[e._v("使用位置：computed")])])]),e._v(" "),v("li",[e._v("sync: 数据更新时直接同步执行 watcher.run 获取值；")]),e._v(" "),v("li",[e._v("剩余所有的 watcher 执行都会统一使用"),v("code",[e._v("scheduler")]),e._v("管理。"),v("code",[e._v("scheduler")]),e._v("会根据 watcher 的 id，依次插入队列中，在 waiting 为 false 时依次执行。全部执行结束之后调用"),v("code",[e._v("nextTick")]),e._v("。\n"),v("ul",[v("li",[e._v("使用位置：updateComponent")])])])]),e._v(" "),v("h2",{attrs:{id:"内部-patch-说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内部-patch-说明"}},[e._v("#")]),e._v(" （内部）patch 说明")]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("vm._init()\n|_ vm._mount()\n  |_ vm._update(vm._render(), hydrating)\n    |_ vm.__patch__\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br")])]),v("ul",[v("li",[v("code",[e._v("_render")]),e._v("通过调用"),v("code",[e._v("createElement")]),e._v("创建了 vnode 树\n"),v("ul",[v("li",[e._v("从目前代码了解到，当数据更新时，会完全重新创建一个新的 vnode 树")]),e._v(" "),v("li",[e._v("但是如果是子组件自己的 render 更新，那么相当于至在子组件数据范围内做 vnode 比较及更新，即每个 vm 实例就是 vnode 更新的最大范围")])])]),e._v(" "),v("li",[v("code",[e._v("_update")]),e._v("方法拿到 vnode 树，调用 patch 开始更新 DOM")])]),e._v(" "),v("h2",{attrs:{id:"其他细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他细节"}},[e._v("#")]),e._v(" 其他细节")]),e._v(" "),v("h3",{attrs:{id:"nexttick"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[e._v("#")]),e._v(" nextTick")]),e._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),v("ul",[v("li",[e._v("数据本身通过"),v("code",[e._v("observe")]),e._v("方法重写"),v("code",[e._v("get")]),e._v("、"),v("code",[e._v("set")]),e._v("方法变为可以搜集依赖，可以在更改时通知依赖")]),e._v(" "),v("li",[e._v("在用到数据的地方，会新建一个"),v("code",[e._v("watcher")]),e._v("，\n"),v("ul",[v("li",[e._v("这个 watcher 初始时因为需要获取数据值而触发了数据的"),v("code",[e._v("get")]),e._v("这时")]),e._v(" "),v("li",[e._v("当前的 watcher 被添加到了数据的"),v("code",[e._v("Dep")]),e._v("列表中")]),e._v(" "),v("li",[e._v("当数据更新时，通知 watcher 更新对应的操作")]),e._v(" "),v("li",[e._v("watcher 更新之后会调用 nextTick")]),e._v(" "),v("li",[e._v("视图渲染及更新就是一个 watcher，调用"),v("code",[e._v("updateComponent")])])])])])])}),[],!1,null,null,null);t.default=a.exports}}]);